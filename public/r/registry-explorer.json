{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "registry-explorer",
  "type": "registry:block",
  "title": "Registry Explorer",
  "description": "A file explorer component for browsing and viewing registry component files with syntax highlighting and copy functionality.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/registry-explorer/components/registry-explorer.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { ChevronRight, ChevronDown, File, Folder, FolderOpen, Loader2, AlertCircle, Copy, Check } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\n\n// Types\ninterface RegistryItem {\n  name: string;\n  type: string;\n  title: string;\n  description: string;\n  files: Array<{\n    path: string;\n    type: string;\n    target: string;\n  }>;\n  dependencies?: string[];\n  registryDependencies?: string[];\n}\n\ninterface FileContent {\n  content: string;\n  path: string;\n  component: string;\n}\n\ninterface TreeNode {\n  name: string;\n  type: 'folder' | 'file';\n  path: string;\n  fullPath: string;\n  children?: TreeNode[];\n  fileType?: string;\n}\n\nasync function fetchComponent(componentName: string): Promise<RegistryItem> {\n  const response = await fetch(`/api/registry/${componentName}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch component: ${componentName}`);\n  }\n  return response.json();\n}\n\nasync function fetchFileContent(\n  componentName: string, \n  filePath: string\n): Promise<FileContent> {\n  // Convert registry path to API path\n  // For paths like \"registry/ui/badge.tsx\" or \"registry/mode-toggle/components/mode-toggle.tsx\"\n  const pathWithoutRegistry = filePath.startsWith('registry/') \n    ? filePath.slice('registry/'.length) \n    : filePath;\n  \n  // The API path should be the path after 'registry/'\n  const apiPath = pathWithoutRegistry;\n  \n  const response = await fetch(`/api/registry/${componentName}/files/${apiPath}`);\n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error(`API Error: ${response.status} - ${errorText}`);\n    throw new Error(`Failed to fetch file: ${filePath} (${response.status})`);\n  }\n  return response.json();\n}\n\nfunction buildFileTree(files: Array<{ path: string }>): TreeNode {\n  const root: TreeNode = {\n    name: 'root',\n    type: 'folder',\n    path: '',\n    fullPath: '',\n    children: []\n  };\n\n  files.forEach(file => {\n    // Skip the 'registry' part of the path since we don't want to show it\n    const pathParts = file.path.split('/').filter(Boolean);\n    if (pathParts[0] === 'registry') {\n      pathParts.shift(); // Remove 'registry' from the path\n    }\n    \n    let currentNode = root;\n    let currentPath = '';\n\n    pathParts.forEach((part, index) => {\n      currentPath = currentPath ? `${currentPath}/${part}` : part;\n      const isFile = index === pathParts.length - 1;\n      \n      let childNode = currentNode.children?.find(child => child.name === part);\n      \n      if (!childNode) {\n        childNode = {\n          name: part,\n          type: isFile ? 'file' : 'folder',\n          path: currentPath,\n          fullPath: isFile ? file.path : currentPath, // Use currentPath for folders, file.path for files\n          children: isFile ? undefined : []\n        };\n        \n        currentNode.children = currentNode.children || [];\n        currentNode.children.push(childNode);\n      }\n      \n      if (!isFile) {\n        currentNode = childNode;\n      }\n    });\n  });\n\n  // Sort children alphabetically (folders first, then files)\n  const sortChildren = (node: TreeNode) => {\n    if (node.children) {\n      node.children.sort((a, b) => {\n        // Folders come before files\n        if (a.type !== b.type) {\n          return a.type === 'folder' ? -1 : 1;\n        }\n        // Within the same type, sort alphabetically\n        return a.name.localeCompare(b.name);\n      });\n      \n      // Recursively sort children\n      node.children.forEach(sortChildren);\n    }\n  };\n  \n  sortChildren(root);\n  return root;\n}\n\n// File Explorer Component\nexport interface RegistryExplorerProps {\n  /** The name of the component to explore */\n  componentName: string;\n  /** Optional CSS class name for styling */\n  className?: string;\n  /** Optional path to a specific file to select by default. If not provided, the first file will be selected. */\n  defaultSelectedFile?: string;\n}\n\nexport function RegistryExplorer({ componentName, className, defaultSelectedFile }: RegistryExplorerProps) {\n  const [componentData, setComponentData] = useState<RegistryItem | null>(null);\n  const [selectedFile, setSelectedFile] = useState<string | null>(null);\n  const [fileContent, setFileContent] = useState<string | null>(null);\n  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());\n  const [loading, setLoading] = useState(true);\n  const [fileLoading, setFileLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [copied, setCopied] = useState(false);\n\n  // Load file content\n  const loadFileContent = useCallback(async (filePath: string) => {\n    try {\n      setFileLoading(true);\n      setSelectedFile(filePath);\n      const content = await fetchFileContent(componentName, filePath);\n      setFileContent(content.content);\n    } catch (err) {\n      setFileContent(`// Error loading file: ${err instanceof Error ? err.message : 'Unknown error'}`);\n    } finally {\n      setFileLoading(false);\n    }\n  }, [componentName]);\n\n  // Load component data\n  useEffect(() => {\n    async function loadComponent() {\n      try {\n        setLoading(true);\n        setError(null);\n        const data = await fetchComponent(componentName);\n        setComponentData(data);\n        \n        // Auto-expand all folders in the file tree\n        const allFolders = new Set<string>();\n        data.files.forEach(file => {\n          const pathParts = file.path.split('/').filter(Boolean);\n          // Skip registry prefix for folder path calculation\n          if (pathParts[0] === 'registry') {\n            pathParts.shift();\n          }\n          \n          let currentPath = '';\n          // Add each folder level to the expanded set\n          for (let i = 0; i < pathParts.length - 1; i++) {\n            currentPath = currentPath ? `${currentPath}/${pathParts[i]}` : pathParts[i];\n            allFolders.add(currentPath);\n          }\n        });\n        setExpandedFolders(allFolders);\n        \n        // Auto-select the first file or the specified default file\n        const fileToSelect = defaultSelectedFile \n          ? data.files.find(file => file.path === defaultSelectedFile)?.path\n          : data.files[0]?.path;\n          \n        if (fileToSelect) {\n          loadFileContent(fileToSelect);\n        }\n        \n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to load component');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadComponent();\n  }, [componentName, defaultSelectedFile, loadFileContent]);\n\n  // Build file tree\n  const fileTree = useMemo(() => {\n    if (!componentData) return null;\n    return buildFileTree(componentData.files);\n  }, [componentData]);\n\n  const toggleFolder = (path: string) => {\n    const newExpanded = new Set(expandedFolders);\n    if (newExpanded.has(path)) {\n      newExpanded.delete(path);\n    } else {\n      newExpanded.add(path);\n    }\n    setExpandedFolders(newExpanded);\n  };\n\n  const copyToClipboard = async () => {\n    if (fileContent) {\n      try {\n        await navigator.clipboard.writeText(fileContent);\n        setCopied(true);\n        setTimeout(() => setCopied(false), 2000);\n      } catch (err) {\n        console.error('Failed to copy to clipboard:', err);\n      }\n    }\n  };\n\n  const renderTree = (node: TreeNode, level: number = 0) => {\n    if (node.name === 'root') {\n      return (\n        <div>\n          {node.children?.map(child => renderTree(child, level))}\n        </div>\n      );\n    }\n\n    const isExpanded = expandedFolders.has(node.type === 'folder' ? node.path : node.fullPath);\n    const isSelected = selectedFile === node.fullPath;\n    \n    return (\n      <div key={node.fullPath}>\n        <div\n          className={cn(\n            \"flex items-center gap-2 py-1 px-2 cursor-pointer hover:bg-accent/50 rounded-sm transition-colors text-muted-foreground\",\n            isSelected && \"bg-accent text-foreground\",\n            level > 0 && \"ml-4\"\n          )}\n          onClick={() => {\n            if (node.type === 'folder') {\n              toggleFolder(node.path);\n            } else {\n              loadFileContent(node.fullPath);\n            }\n          }}\n          style={{ paddingLeft: `${level * 6 + 8}px` }}\n        >\n          {node.type === 'folder' ? (\n            <>\n              {isExpanded ? (\n                <ChevronDown className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n              ) : (\n                <ChevronRight className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n              )}\n              {isExpanded ? (\n                <FolderOpen className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n              ) : (\n                <Folder className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n              )}\n            </>\n          ) : (\n            <>\n              <div className=\"w-4\" />\n              <File className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n            </>\n          )}\n          <span className=\"text-sm font-medium truncate\">{node.name}</span>\n          {node.type === 'file' && node.fileType && (\n            <span className=\"text-xs text-muted-foreground ml-auto\">\n              {node.fileType}\n            </span>\n          )}\n        </div>\n        \n        {node.type === 'folder' && isExpanded && node.children && (\n          <div>\n            {node.children.map(child => renderTree(child, level + 1))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  if (loading) {\n    return (\n      <div className={cn(\"flex items-center justify-center h-[600px] border rounded-lg\", className)}>\n        <div className=\"flex items-center gap-2\">\n          <Loader2 className=\"size-4 animate-spin\" />\n          <span>Loading component...</span>\n        </div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className={cn(\"flex items-center justify-center h-[600px] border rounded-lg\", className)}>\n        <div className=\"flex items-center gap-2 text-destructive\">\n          <AlertCircle className=\"size-4 shrink-0\" />\n          <span>{error}</span>\n        </div>\n      </div>\n    );\n  }\n\n  if (!fileTree) {\n    return (\n      <div className={cn(\"p-4 text-center text-muted-foreground border rounded-lg\", className)}>\n        Component &quot;{componentName}&quot; not found in registry\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn(\"flex h-[600px] border rounded-lg overflow-hidden\", className)}>\n      {/* File Explorer Sidebar */}\n      <div className=\"w-[16rem] min-w-[16rem] border-r bg-muted/30 overflow-y-auto shrink-0\">\n        <div className=\"p-2\">\n          {renderTree(fileTree)}\n        </div>\n      </div>\n\n      {/* Code Display */}\n      <div className=\"flex-1 flex flex-col min-w-0\">\n        {selectedFile ? (\n          <>\n            <div className=\"px-4 py-2 border-b bg-muted/30 flex items-center justify-between\">\n              <div className=\"flex items-center gap-2\">\n                <File className=\"size-4 shrink-0\" strokeWidth={1.5}/>\n                <span className=\"text-sm font-medium\">{selectedFile.split('/').pop()}</span>\n                {fileLoading && <Loader2 className=\"size-3 animate-spin\" />}\n              </div>\n              <Button\n                onClick={copyToClipboard}\n                disabled={!fileContent || fileLoading}\n                variant=\"outline\"\n                size=\"sm\"\n              >\n                {copied ? (\n                  <>\n                    <Check className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                  </>\n                ) : (\n                  <>\n                    <Copy className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                  </>\n                )}\n              </Button>\n            </div>\n            <div className=\"flex-1 overflow-auto\">\n              {fileLoading ? (\n                <div className=\"flex items-center justify-center h-full\">\n                  <div className=\"flex items-center gap-2\">\n                    <Loader2 className=\"size-4 animate-spin\" />\n                    <span className=\"text-sm text-muted-foreground\">Loading file...</span>\n                  </div>\n                </div>\n              ) : (\n                <div className=\"overflow-auto h-full\">\n                  <div className=\"flex min-w-max\">\n                    {/* Line numbers */}\n                    <div className=\"pl-4 py-4 select-none text-muted-foreground\">\n                      <pre className=\"text-sm font-mono leading-relaxed text-muted-foreground text-right\">\n                        {fileContent && fileContent.split('\\n').map((_, index) => (\n                          <div key={index + 1}>{index + 1}</div>\n                        ))}\n                      </pre>\n                    </div>\n                    {/* Code content */}\n                    <div className=\"flex-1\">\n                      <pre className=\"p-4 text-sm font-mono leading-relaxed whitespace-pre\">\n                        <code>\n                          {fileContent}\n                        </code>\n                      </pre>\n                    </div>\n                  </div>\n                </div>\n              )}\n            </div>\n          </>\n        ) : (\n          <div className=\"flex-1 flex items-center justify-center text-muted-foreground\">\n            <div className=\"text-center\">\n              <File className=\"size-12 mx-auto mb-4 opacity-50\" strokeWidth={1.5}/>\n              <p className=\"text-lg font-medium mb-2\">Select a file to view its contents</p>\n              <p className=\"text-sm\">Click on any file in the tree to view its source code</p>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Export the RegistryExplorer as the default component\nexport default RegistryExplorer;",
      "type": "registry:component",
      "target": "components/registry-explorer.tsx"
    },
    {
      "path": "registry/registry-explorer/lib/api.ts",
      "content": "// lib/api.ts - Client-side API functions\nexport interface RegistryItem {\n    name: string;\n    type: string;\n    title: string;\n    description: string;\n    files: Array<{\n      path: string;\n      type: string;\n      target: string;\n    }>;\n    dependencies?: string[];\n    registryDependencies?: string[];\n  }\n  \n  export interface Registry {\n    items: RegistryItem[];\n  }\n  \n  export interface FileContent {\n    content: string;\n    path: string;\n    component: string;\n  }\n  \n  // Fetch the full registry\n  export async function fetchRegistry(): Promise<Registry> {\n    const response = await fetch('/api/registry');\n    if (!response.ok) {\n      throw new Error('Failed to fetch registry');\n    }\n    return response.json();\n  }\n  \n  // Fetch a specific component's data\n  export async function fetchComponent(componentName: string): Promise<RegistryItem> {\n    const response = await fetch(`/api/registry/${componentName}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch component: ${componentName}`);\n    }\n    return response.json();\n  }\n  \n  // Fetch file content\n  export async function fetchFileContent(\n    componentName: string, \n    filePath: string\n  ): Promise<FileContent> {\n    // Convert registry path to API path\n    // e.g., \"registry/ui/badge.tsx\" -> \"ui/badge.tsx\"\n    const pathWithoutRegistry = filePath.startsWith('registry/') \n      ? filePath.slice('registry/'.length) \n      : filePath;\n    \n    // Remove component name from path if it's there\n    const pathParts = pathWithoutRegistry.split('/');\n    if (pathParts[0] === componentName) {\n      pathParts.shift();\n    }\n    \n    const apiPath = pathParts.join('/');\n    \n    const response = await fetch(`/api/registry/${componentName}/files/${apiPath}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file: ${filePath}`);\n    }\n    return response.json();\n  }",
      "type": "registry:lib",
      "target": "lib/api.ts"
    },
    {
      "path": "registry/registry-explorer/utils/file-tree.ts",
      "content": "// utils/file-tree.ts - Utility for building file trees\nexport interface TreeNode {\n    name: string;\n    type: 'folder' | 'file';\n    path: string;\n    fullPath: string;\n    children?: TreeNode[];\n    fileType?: string;\n  }\n  \n  export function buildFileTree(files: Array<{ path: string }>): TreeNode {\n    const root: TreeNode = {\n      name: 'root',\n      type: 'folder',\n      path: '',\n      fullPath: '',\n      children: []\n    };\n  \n    files.forEach(file => {\n      const pathParts = file.path.split('/').filter(Boolean);\n      let currentNode = root;\n      let currentPath = '';\n  \n      pathParts.forEach((part, index) => {\n        currentPath = currentPath ? `${currentPath}/${part}` : part;\n        const isFile = index === pathParts.length - 1;\n        \n        // Find existing node or create new one\n        let childNode = currentNode.children?.find(child => child.name === part);\n        \n        if (!childNode) {\n          childNode = {\n            name: part,\n            type: isFile ? 'file' : 'folder',\n            path: currentPath,\n            fullPath: file.path,\n            children: isFile ? undefined : []\n          };\n          \n          if (isFile) {\n            childNode.fileType = getFileType(part);\n          }\n          \n          currentNode.children = currentNode.children || [];\n          currentNode.children.push(childNode);\n        }\n        \n        if (!isFile) {\n          currentNode = childNode;\n        }\n      });\n    });\n  \n    return root;\n  }\n  \n  function getFileType(fileName: string): string {\n    const ext = fileName.split('.').pop()?.toLowerCase();\n    switch (ext) {\n      case 'tsx':\n      case 'ts':\n        return 'typescript';\n      case 'jsx':\n      case 'js':\n        return 'javascript';\n      case 'css':\n        return 'css';\n      case 'json':\n        return 'json';\n      case 'md':\n      case 'mdx':\n        return 'markdown';\n      default:\n        return 'text';\n    }\n  }",
      "type": "registry:lib",
      "target": "utils/file-tree.ts"
    },
    {
      "path": "registry/registry-explorer/api/registry/route.ts",
      "content": "// src/app/api/registry/route.ts\nimport { NextResponse } from 'next/server';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\n\nexport async function GET() {\n  try {\n    const registryPath = join(process.cwd(), 'registry.json');\n    \n    if (!existsSync(registryPath)) {\n      return NextResponse.json(\n        { error: 'Registry not found' },\n        { status: 404 }\n      );\n    }\n\n    const registryContent = await readFile(registryPath, 'utf-8');\n    const registry = JSON.parse(registryContent);\n    \n    return NextResponse.json(registry);\n\n  } catch (error) {\n    console.error('Error reading registry:', error);\n    return NextResponse.json(\n      { error: 'Failed to read registry' },\n      { status: 500 }\n    );\n  }\n}\n\n\n\n",
      "type": "registry:file",
      "target": "app/api/registry/route.ts"
    },
    {
      "path": "registry/registry-explorer/api/registry/[component]/route.ts",
      "content": "// src/app/api/registry/[component]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\nimport { RegistryItem } from '@/lib/api';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ component: string }> }\n) {\n  try {\n    const { component } = await params;\n    \n    // Read the registry.json file\n    const registryPath = join(process.cwd(), 'registry.json');\n    \n    if (!existsSync(registryPath)) {\n      return NextResponse.json(\n        { error: 'Registry not found' },\n        { status: 404 }\n      );\n    }\n\n    const registryContent = await readFile(registryPath, 'utf-8');\n    const registry = JSON.parse(registryContent);\n    \n    // Find the specific component\n    const componentData = registry.items?.find((item: RegistryItem) => item.name === component);\n    \n    if (!componentData) {\n      return NextResponse.json(\n        { error: 'Component not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json(componentData);\n\n  } catch (error) {\n    console.error('Error reading registry:', error);\n    return NextResponse.json(\n      { error: 'Failed to read registry' },\n      { status: 500 }\n    );\n  }\n}\n\n",
      "type": "registry:file",
      "target": "app/api/registry/[component]/route.ts"
    },
    {
      "path": "registry/registry-explorer/api/registry/[component]/files/[...path]/route.ts",
      "content": "// src/app/api/registry/[component]/files/[...path]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ component: string; path: string[] }> }\n) {\n  try {\n    const { component, path } = await params;\n    \n    // Reconstruct the full path\n    const fullPath = path.join('/');\n    \n    // The file path should be: registry + fullPath\n    const filePath = join(process.cwd(), 'registry', fullPath);\n    \n    console.log(`Attempting to read file: ${filePath}`);\n    \n    // Security check: ensure the path is within the registry directory\n    const registryPath = join(process.cwd(), 'registry');\n    if (!filePath.startsWith(registryPath)) {\n      return NextResponse.json(\n        { error: 'Invalid file path' },\n        { status: 403 }\n      );\n    }\n\n    // Check if file exists\n    if (!existsSync(filePath)) {\n      console.error(`File not found: ${filePath}`);\n      return NextResponse.json(\n        { error: `File not found: ${fullPath}` },\n        { status: 404 }\n      );\n    }\n\n    // Read file content\n    const content = await readFile(filePath, 'utf-8');\n    \n    return NextResponse.json({\n      content,\n      path: fullPath,\n      component\n    });\n\n  } catch (error) {\n    console.error('Error reading file:', error);\n    return NextResponse.json(\n      { error: `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}` },\n      { status: 500 }\n    );\n  }\n}",
      "type": "registry:file",
      "target": "app/api/registry/[component]/files/[...path]/route.ts"
    }
  ]
}