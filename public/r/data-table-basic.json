{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-basic",
  "type": "registry:block",
  "title": "Data Table Basic",
  "description": "A simplified data table component with essential features including sorting, pagination, row editing, and CRUD operations. Perfect for basic use cases with Supabase integration.",
  "dependencies": [
    "@tanstack/react-table",
    "@supabase/supabase-js",
    "lucide-react",
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "sonner",
    "next"
  ],
  "registryDependencies": [
    "table",
    "button",
    "input",
    "select",
    "checkbox",
    "badge",
    "dropdown-menu",
    "dialog",
    "alert-dialog",
    "label"
  ],
  "files": [
    {
      "path": "registry/data-table-basic/components/data-table.tsx",
      "content": "\"use client\"\n\nimport {\n  ColumnDef,\n  flexRender,\n  getCoreRowModel,\n  useReactTable,\n  SortingState,\n  VisibilityState,\n  ColumnFiltersState,\n  ColumnOrderState,\n} from \"@tanstack/react-table\"\nimport { useRouter, useSearchParams, usePathname } from \"next/navigation\"\nimport { useCallback, useState, useEffect } from \"react\"\n\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\"\nimport DataTableToolbar from \"./data-table-toolbar\"\nimport { DataTablePagination } from \"./data-table-pagination\"\nimport { parseSearchParams, serializeTableState, updateSearchParams as updateUrlSearchParams, DataTableState } from \"@/lib/data-table\"\n\ninterface DataTableProps<TData, TValue> {\n  columns: ColumnDef<TData, TValue>[]\n  data: TData[]\n  searchParams: { [key: string]: string | string[] | undefined }\n  totalCount: number\n  createAction: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateAction: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  deleteAction: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n}\n\nexport function DataTable<TData extends { id: string }, TValue>({\n  columns,\n  data,\n  searchParams,\n  totalCount,\n  createAction,\n  updateAction,\n  deleteAction,\n}: DataTableProps<TData, TValue>) {\n  const router = useRouter()\n  const pathname = usePathname()\n  const currentSearchParams = useSearchParams()\n\n  // Parse initial state from search params\n  const tableState = parseSearchParams(searchParams)\n  const page = (tableState.pagination?.pageIndex ?? 0) + 1 // Convert 0-based to 1-based\n  const pageSize = tableState.pagination?.pageSize ?? 10\n\n  // State management for table features\n  const [sorting, setSorting] = useState<SortingState>(tableState.sorting ?? [])\n  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>(tableState.columnVisibility ?? {})\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>(tableState.columnFilters ?? [])\n  const [columnOrder, setColumnOrder] = useState<ColumnOrderState>(tableState.columnOrder ?? [])\n\n  // Sync state changes to URL\n  useEffect(() => {\n    const currentState: DataTableState = {\n      pagination: {\n        pageIndex: page - 1, // Convert to 0-based\n        pageSize,\n      },\n      sorting,\n      columnFilters,\n      columnVisibility,\n      columnOrder,\n    }\n\n    const newParams = serializeTableState(currentState)\n    const updatedSearchParams = updateUrlSearchParams(currentSearchParams, newParams)\n    \n    // Only update URL if parameters actually changed\n    const currentUrl = `${pathname}?${currentSearchParams.toString()}`\n    const newUrl = `${pathname}?${updatedSearchParams.toString()}`\n    \n    if (currentUrl !== newUrl) {\n      router.replace(newUrl, { scroll: false })\n    }\n  }, [sorting, columnFilters, columnVisibility, columnOrder, page, pageSize, router, pathname, currentSearchParams])\n\n  const updateSearchParams = useCallback(\n    (updates: { page?: number; pageSize?: number }) => {\n      const currentTableState = parseSearchParams(\n        Object.fromEntries(currentSearchParams.entries())\n      )\n      \n      // Update pagination state\n      const newTableState = {\n        pagination: {\n          pageIndex: (updates.page ?? page) - 1, // Convert to 0-based\n          pageSize: updates.pageSize ?? pageSize,\n        },\n        sorting: currentTableState.sorting ?? [],\n        columnFilters: currentTableState.columnFilters ?? [],\n        columnVisibility: currentTableState.columnVisibility ?? {},\n        columnOrder: currentTableState.columnOrder ?? [],\n      }\n      \n      const serializedParams = serializeTableState(newTableState)\n      const newSearchParams = updateUrlSearchParams(currentSearchParams, serializedParams)\n      const url = newSearchParams.toString()\n      router.push(url ? `?${url}` : '?', { scroll: false })\n    },\n    [currentSearchParams, router, page, pageSize]\n  )\n\n  const table = useReactTable({\n    data,\n    columns,\n    getCoreRowModel: getCoreRowModel(),\n    manualPagination: true,\n    manualSorting: true,\n    rowCount: totalCount,\n    enableRowSelection: true,\n    getRowId: (row: TData) => (row as { id: string }).id, // Use the id field as row identifier\n    state: {\n      pagination: {\n        pageIndex: page - 1, // Convert to 0-based index\n        pageSize,\n      },\n      sorting,\n      columnVisibility,\n      columnFilters,\n      columnOrder,\n    },\n    onPaginationChange: (updater) => {\n      const newPagination = typeof updater === 'function' \n        ? updater({ pageIndex: page - 1, pageSize })\n        : updater\n      \n      updateSearchParams({\n        page: newPagination.pageIndex + 1, // Convert back to 1-based\n        pageSize: newPagination.pageSize,\n      })\n    },\n    onSortingChange: setSorting,\n    onColumnVisibilityChange: setColumnVisibility,\n    onColumnFiltersChange: setColumnFilters,\n    onColumnOrderChange: setColumnOrder,\n  })\n\n  return (\n    <div className=\"space-y-2\">\n      <div className=\"\">\n        <DataTableToolbar \n          table={table} \n          createAction={createAction}\n          updateAction={updateAction}\n          deleteAction={deleteAction}\n        />\n      </div>\n      <div className=\"rounded-md border\">\n        <Table>\n          <TableHeader>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <TableRow key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <TableHead key={header.id}>\n                      {header.isPlaceholder\n                        ? null\n                        : flexRender(\n                            header.column.columnDef.header,\n                            header.getContext()\n                          )}\n                    </TableHead>\n                  )\n                })}\n              </TableRow>\n            ))}\n          </TableHeader>\n          <TableBody>\n            {table.getRowModel().rows?.length ? (\n              table.getRowModel().rows.map((row) => (\n                <TableRow\n                  key={row.id}\n                  data-state={row.getIsSelected() && \"selected\"}\n                >\n                  {row.getVisibleCells().map((cell) => (\n                    <TableCell key={cell.id}>\n                      {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                    </TableCell>\n                  ))}\n                </TableRow>\n              ))\n            ) : (\n              <TableRow>\n                <TableCell colSpan={columns.length} className=\"h-24 text-center\">\n                  No results.\n                </TableCell>\n              </TableRow>\n            )}\n          </TableBody>\n        </Table>\n      </div>\n      <div className=\"\">\n        <DataTablePagination table={table} />\n      </div>\n    </div>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-column-header.tsx",
      "content": "import { Column } from \"@tanstack/react-table\"\nimport { ArrowDown, ArrowUp, ChevronsUpDown, EyeOff } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\n\ninterface DataTableColumnHeaderProps<TData, TValue>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  column: Column<TData, TValue>\n  title: string\n}\n\nexport function DataTableColumnHeader<TData, TValue>({\n  column,\n  title,\n  className,\n}: DataTableColumnHeaderProps<TData, TValue>) {\n  if (!column.getCanSort()) {\n    return <div className={cn(className)}>{title}</div>\n  }\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"data-[state=open]:bg-accent -ml-3 h-8\"\n          >\n            <span>{title}</span>\n            {column.getIsSorted() === \"desc\" ? (\n              <ArrowDown />\n            ) : column.getIsSorted() === \"asc\" ? (\n              <ArrowUp />\n            ) : (\n              <ChevronsUpDown />\n            )}\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"start\">\n          <DropdownMenuItem onClick={() => column.toggleSorting(false)}>\n            <ArrowUp />\n            Asc\n          </DropdownMenuItem>\n          <DropdownMenuItem onClick={() => column.toggleSorting(true)}>\n            <ArrowDown />\n            Desc\n          </DropdownMenuItem>\n          <DropdownMenuSeparator />\n          <DropdownMenuItem onClick={() => column.toggleVisibility(false)}>\n            <EyeOff />\n            Hide\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-column-header.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-pagination.tsx",
      "content": "import { Table } from \"@tanstack/react-table\"\nimport {\n  ChevronLeft,\n  ChevronRight,\n  ChevronsLeft,\n  ChevronsRight,\n} from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\n\ninterface DataTablePaginationProps<TData> {\n  table: Table<TData>\n}\n\nexport function DataTablePagination<TData>({\n  table,\n}: DataTablePaginationProps<TData>) {\n  return (\n    <div className=\"flex items-center justify-between\">\n      {/* selected */}\n      <div className=\"text-muted-foreground flex-1 text-sm\">\n        <span className=\"hidden sm:inline\">\n          {table.getFilteredSelectedRowModel().rows.length} of{\" \"}\n          {table.getFilteredRowModel().rows.length} selected.\n        </span>\n        <span className=\"sm:hidden\">\n          {table.getFilteredSelectedRowModel().rows.length} selected\n        </span>\n      </div>\n\n      {/* rows per page */}\n      <div className=\"flex items-center justify-center space-x-2 flex-1\">\n        <p className=\"text-sm font-medium hidden sm:inline\">Rows per page</p>\n        <p className=\"text-sm font-medium sm:hidden\">Rows</p>\n        <Select\n          value={`${table.getState().pagination.pageSize}`}\n          onValueChange={(value) => {\n            table.setPageSize(Number(value))\n          }}\n        >\n          <SelectTrigger className=\"h-8 w-[70px]\">\n            <SelectValue placeholder={table.getState().pagination.pageSize} />\n          </SelectTrigger>\n          <SelectContent side=\"top\">\n            {[10, 20, 25, 30, 40, 50].map((pageSize) => (\n              <SelectItem key={pageSize} value={`${pageSize}`}>\n                {pageSize}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* pagination */}\n      <div className=\"flex items-center justify-end gap-4 flex-1\">\n        <div className=\"flex w-[fit] items-center justify-center text-sm font-medium\">\n          <span className=\"hidden sm:inline\">\n            Page {table.getState().pagination.pageIndex + 1} of{\" \"}\n            {table.getPageCount()}\n          </span>\n          <span className=\"sm:hidden\">\n            Page {table.getState().pagination.pageIndex + 1}\n          </span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"hidden size-8 lg:flex\"\n            onClick={() => table.setPageIndex(0)}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <span className=\"sr-only\">Go to first page</span>\n            <ChevronsLeft />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"size-8\"\n            onClick={() => table.previousPage()}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <span className=\"sr-only\">Go to previous page</span>\n            <ChevronLeft />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"size-8\"\n            onClick={() => table.nextPage()}\n            disabled={!table.getCanNextPage()}\n          >\n            <span className=\"sr-only\">Go to next page</span>\n            <ChevronRight />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"hidden size-8 lg:flex\"\n            onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n            disabled={!table.getCanNextPage()}\n          >\n            <span className=\"sr-only\">Go to last page</span>\n            <ChevronsRight />\n          </Button>\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-pagination.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-row-add.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport { Plus } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\"\nimport { Label } from \"@/components/ui/label\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport { Table, Column } from \"@tanstack/react-table\"\n\ninterface DataTableRowAddProps<TData> {\n  table: Table<TData>\n  createAction: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n}\n\nexport default function DataTableRowAdd<TData>({\n  table,\n  createAction,\n}: DataTableRowAddProps<TData>) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [open, setOpen] = useState(false)\n  const [formData, setFormData] = useState<Partial<TData>>({})\n\n  const editableColumns: Column<TData, unknown>[] = table\n    .getAllColumns()\n    .filter((col) => col.columnDef.meta?.fieldType)\n\n  const handleChange = (name: keyof TData, value: string | number) => {\n    setFormData(prev => ({ ...prev, [name]: value }))\n  }\n\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n    setIsSubmitting(true)\n    try {\n      const result = await createAction(formData)\n      if (result.success) {\n        toast.success(\"Row added\", {\n          description: \"New item has been added successfully.\",\n        })\n        router.refresh()\n        setOpen(false)\n        setFormData({})\n      } else {\n        toast.error(\"Creation failed\", {\n          description: result.error || \"An unknown error occurred.\",\n        })\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"An unexpected error occurred.\"\n      toast.error(\"Creation failed\", {\n        description: errorMessage,\n      })\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        <Button variant=\"outline\">\n          <Plus className=\"size-4 shrink-0\" />\n        </Button>\n      </DialogTrigger>\n      <DialogContent className=\"sm:max-w-[425px]\">\n        <DialogHeader>\n          <DialogTitle>Add New Item</DialogTitle>\n          <DialogDescription>\n            Fill in the details to add a new item.\n          </DialogDescription>\n        </DialogHeader>\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            {editableColumns.map((col) => (\n              <div key={col.id} className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor={col.id} className=\"text-right\">\n                  {col.columnDef.meta?.label || col.id}\n                </Label>\n                <div className=\"col-span-3\">\n                {col.columnDef.meta?.fieldType === \"select\" ? (\n                  <Select onValueChange={(value) => handleChange(col.id as keyof TData, value)}>\n                    <SelectTrigger>\n                      <SelectValue placeholder={col.columnDef.meta?.placeholder} />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {(col.columnDef.meta?.options as (string | { value: string; label: string })[])?.map((option) => (\n                        <SelectItem\n                          key={typeof option === 'string' ? option : option.value}\n                          value={typeof option === 'string' ? option : option.value}\n                        >\n                          {typeof option === 'string' ? option : option.label}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                ) : (\n                  <Input\n                    id={col.id}\n                    type={col.columnDef.meta?.fieldType || \"text\"}\n                    placeholder={col.columnDef.meta?.placeholder}\n                    value={(formData[col.id as keyof TData] as string) || \"\"}\n                    onChange={(e) => handleChange(col.id as keyof TData, e.target.value)}\n                    className=\"col-span-3\"\n                  />\n                )}\n                </div>\n              </div>\n            ))}\n          </div>\n          <DialogFooter>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={() => setOpen(false)}\n              disabled={isSubmitting}\n            >\n              Cancel\n            </Button>\n            <Button type=\"submit\" disabled={isSubmitting}>\n              {isSubmitting ? \"Adding...\" : \"Add Item\"}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  )\n} ",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-row-add.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-row-delete.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport { Trash2 } from \"lucide-react\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\"\n\nexport interface DataTableRowDeleteProps {\n  selectedRowIds: string[]\n  deleteAction: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  onComplete?: () => void\n}\n\nexport default function DataTableRowDelete({ \n  selectedRowIds, \n  deleteAction,\n  onComplete \n}: DataTableRowDeleteProps) {\n  const router = useRouter()\n  const [isDeleting, setIsDeleting] = useState(false)\n  const [open, setOpen] = useState(false)\n\n  const handleDelete = async () => {\n    setIsDeleting(true)\n    \n    try {\n      const result = await deleteAction(selectedRowIds)\n      \n      if (result.success) {\n        toast.success(\"Row deleted\", {\n          description: `${result.deletedCount || selectedRowIds.length} row(s) have been deleted.`,\n        })\n        router.refresh()\n        onComplete?.()\n        setOpen(false)\n      } else {\n        toast.error(\"Deletion failed\", {\n          description: result.error || \"An unknown error occurred.\",\n        })\n        console.error(\"Failed to delete rows:\", result.error)\n      }\n    } catch (error) {\n      toast.error(\"Deletion failed\", {\n        description: \"An unexpected error occurred while deleting the rows.\",\n      })\n      console.error(\"Error deleting rows:\", error)\n    } finally {\n      setIsDeleting(false)\n    }\n  }\n\n  if (selectedRowIds.length === 0) {\n    return null\n  }\n\n  return (\n    <AlertDialog open={open} onOpenChange={setOpen}>\n      <AlertDialogTrigger asChild>\n        <Button variant=\"outline\">\n          <Trash2 className=\"size-4 shrink-0\" />\n          <Badge variant=\"secondary\">{selectedRowIds.length}</Badge>\n        </Button>\n      </AlertDialogTrigger>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>\n            <div className=\"flex items-center gap-2\">\n              Delete <Badge variant=\"secondary\">{selectedRowIds.length}</Badge> {selectedRowIds.length === 1 ? \"Item\" : \"Items\"}\n            </div>\n          </AlertDialogTitle>\n          <AlertDialogDescription>\n            Are you sure you want to delete {selectedRowIds.length} selected row\n            {selectedRowIds.length === 1 ? \"\" : \"s\"}? This action cannot be\n            undone.\n          </AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>\n          <AlertDialogAction\n            onClick={handleDelete}\n            disabled={isDeleting}\n            className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\n          >\n            {isDeleting ? (\n              \"Deleting...\"\n            ) : (\n              <div className=\"flex items-center gap-1\">\n                Delete <Badge variant=\"outline\">{selectedRowIds.length}</Badge> {selectedRowIds.length === 1 ? \"Item\" : \"Items\"}\n              </div>\n            )}\n          </AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  )\n} ",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-row-delete.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-row-edit.tsx",
      "content": "\"use client\"\n\nimport { useState, useEffect } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport {  PencilRuler } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\"\nimport { Label } from \"@/components/ui/label\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport { Table, Column } from \"@tanstack/react-table\"\nimport { Badge } from \"@/components/ui/badge\"\n\ninterface DataTableRowEditProps<TData> {\n  table: Table<TData>\n  updateAction: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  onComplete?: () => void\n}\n\nexport default function DataTableRowEdit<TData extends { id: string }>({ \n  table,\n  updateAction,\n  onComplete \n}: DataTableRowEditProps<TData>) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [open, setOpen] = useState(false)\n  const [formData, setFormData] = useState<Partial<TData>>({})\n\n  const selectedRows = table.getFilteredSelectedRowModel().rows\n  const isMultipleRows = selectedRows.length > 1\n  const isSingleRow = selectedRows.length === 1\n\n  const editableColumns: Column<TData, unknown>[] = table\n    .getAllColumns()\n    .filter((col) => col.columnDef.meta?.fieldType)\n\n  useEffect(() => {\n    if (isSingleRow) {\n      // For single row, pre-fill with existing data\n      setFormData(selectedRows[0].original)\n    } else {\n      // For multiple rows, start with empty form\n      setFormData({})\n    }\n  }, [selectedRows, isSingleRow])\n\n  const handleChange = (name: keyof TData, value: string | number) => {\n    setFormData(prev => ({ ...prev, [name]: value }))\n  }\n\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n    if (selectedRows.length === 0) return\n    \n    setIsSubmitting(true)\n    \n    try {\n      // Filter out the id field from formData since it's an identity column\n      const updateData = { ...formData }\n      delete updateData.id\n\n      // Only include fields that have values (for multi-row editing)\n      const filteredUpdateData = Object.fromEntries(\n        Object.entries(updateData).filter(([, value]) => value !== undefined && value !== \"\")\n      ) as Partial<TData>\n\n      if (Object.keys(filteredUpdateData).length === 0) {\n        toast.error(\"No changes to apply\", {\n          description: \"Please fill in at least one field to update.\",\n        })\n        setIsSubmitting(false)\n        return\n      }\n\n      let successCount = 0\n      let errorCount = 0\n      let lastError = \"\"\n\n      // Update each selected row\n      for (const row of selectedRows) {\n        try {\n          const result = await updateAction(row.original.id, filteredUpdateData)\n          if (result.success) {\n            successCount++\n          } else {\n            errorCount++\n            lastError = result.error || \"Unknown error\"\n          }\n        } catch (error) {\n          errorCount++\n          lastError = error instanceof Error ? error.message : \"Unexpected error\"\n        }\n      }\n\n      // Show appropriate toast message\n      if (errorCount === 0) {\n        const message = isMultipleRows \n          ? `${successCount} rows updated`\n          : \"Row updated\"\n        const description = isMultipleRows\n          ? `${successCount} items have been updated successfully.`\n          : \"Item has been updated successfully.\"\n        \n        toast.success(message, { description })\n        router.refresh()\n        setOpen(false)\n        onComplete?.()\n      } else if (successCount === 0) {\n        toast.error(\"Update failed\", {\n          description: lastError,\n        })\n      } else {\n        toast.warning(\"Partial update\", {\n          description: `${successCount} rows updated, ${errorCount} failed. Last error: ${lastError}`,\n        })\n        router.refresh()\n        setOpen(false)\n        onComplete?.()\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"An unexpected error occurred.\"\n      toast.error(\"Update failed\", {\n        description: errorMessage,\n      })\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  if (selectedRows.length === 0) {\n    return null\n  }\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        <Button variant=\"outline\">\n          <PencilRuler className=\"size-4 shrink-0\" />\n          <Badge variant=\"secondary\">{selectedRows.length}</Badge>\n        </Button>\n      </DialogTrigger>\n      <DialogContent className=\"sm:max-w-[425px]\">\n        <DialogHeader>\n          <DialogTitle>\n            <div className=\"flex items-center gap-2\">\n              Edit <Badge variant=\"secondary\">{selectedRows.length}</Badge> {selectedRows.length === 1 ? \"Item\" : \"Items\"}\n            </div>\n          </DialogTitle>\n          <DialogDescription>\n            {isMultipleRows \n              ? `Update the fields below to apply changes to all ${selectedRows.length} selected items. Only filled fields will be updated.`\n              : \"Update the item details below.\"\n            }\n          </DialogDescription>\n        </DialogHeader>\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div className=\"space-y-2\">\n          {editableColumns.map((col) => (\n              <div key={col.id} className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor={col.id} className=\"text-right\">\n                  {col.columnDef.meta?.label || col.id}\n                </Label>\n                <div className=\"col-span-3\">\n                {col.columnDef.meta?.fieldType === \"select\" ? (\n                  <Select \n                    onValueChange={(value) => handleChange(col.id as keyof TData, value)}\n                    value={formData[col.id as keyof TData] as string | undefined}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder={\n                        isMultipleRows \n                          ? `Select new ${col.columnDef.meta?.label || col.id}...`\n                          : col.columnDef.meta?.placeholder\n                      } />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {(col.columnDef.meta?.options as (string | { value: string; label: string })[])?.map((option) => (\n                        <SelectItem\n                          key={typeof option === 'string' ? option : option.value}\n                          value={typeof option === 'string' ? option : option.value}\n                        >\n                          {typeof option === 'string' ? option : option.label}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                ) : (\n                  <Input\n                    id={col.id}\n                    type={col.columnDef.meta?.fieldType || \"text\"}\n                    placeholder={\n                      isMultipleRows \n                        ? `New ${col.columnDef.meta?.label || col.id}...`\n                        : col.columnDef.meta?.placeholder\n                    }\n                    value={(formData[col.id as keyof TData] as string) || \"\"}\n                    onChange={(e) => handleChange(col.id as keyof TData, e.target.value)}\n                    className=\"col-span-3\"\n                  />\n                )}\n                </div>\n              </div>\n            ))}\n          </div>\n          <DialogFooter>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={() => setOpen(false)}\n              disabled={isSubmitting}\n            >\n              Cancel\n            </Button>\n            <Button type=\"submit\" disabled={isSubmitting}>\n              {isSubmitting ? (\n                \"Updating...\"\n              ) : (\n                <div className=\"flex items-center gap-1\">\n                  Update <Badge variant=\"secondary\">{selectedRows.length}</Badge> {selectedRows.length === 1 ? \"Item\" : \"Items\"}\n                </div>\n              )}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  )\n} ",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-row-edit.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-toolbar.tsx",
      "content": "import { Table } from \"@tanstack/react-table\"\nimport { DataTableViewOptions } from \"./data-table-view-options\"\nimport DataTableRowDelete from \"./data-table-row-delete\"\nimport DataTableRowAdd from \"./data-table-row-add\"\nimport DataTableRowEdit from \"./data-table-row-edit\"\n\ninterface DataTableToolbarProps<TData> {\n  table: Table<TData>,\n  createAction: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>,\n  updateAction: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>,\n  deleteAction: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>,\n}\n\nexport default function DataTableToolbar<TData extends { id: string }>({ \n  table,\n  createAction,\n  updateAction,\n  deleteAction,\n}: DataTableToolbarProps<TData>) {\n  const selectedRowIds = table.getFilteredSelectedRowModel().rows.map(row => row.original.id)\n\n  return (\n    <div className=\"flex items-center justify-between\">\n      <div className=\"flex items-center gap-2\">\n        <DataTableRowAdd \n          table={table}\n          createAction={createAction} \n        />\n        <DataTableRowEdit\n          table={table}\n          updateAction={updateAction}\n          onComplete={() => table.resetRowSelection()}\n        />\n        <DataTableRowDelete\n          selectedRowIds={selectedRowIds}\n          deleteAction={deleteAction}\n          onComplete={() => table.resetRowSelection()}\n        />\n      </div>\n      <DataTableViewOptions table={table} />\n    </div>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-toolbar.tsx"
    },
    {
      "path": "registry/data-table-basic/components/data-table-view-options.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { Table, Column } from \"@tanstack/react-table\"\nimport { Settings2, Circle, CircleCheckBig, GripVertical } from \"lucide-react\"\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  DragEndEvent,\n} from \"@dnd-kit/core\"\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\"\nimport {\n  useSortable,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\n\ninterface SortableItemProps<TData> {\n  id: string\n  column: Column<TData, unknown>\n  isVisible: boolean\n  onToggleVisibility: () => void\n}\n\nfunction SortableItem<TData>({ id, column, isVisible, onToggleVisibility }: SortableItemProps<TData>) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id })\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n  }\n\n  return (\n    <CommandItem\n      ref={setNodeRef}\n      style={style}\n      className=\"flex items-center justify-between cursor-pointer\"\n      onSelect={onToggleVisibility}\n    >\n      <div className=\"flex items-center space-x-2\">\n        <div\n          {...attributes}\n          {...listeners}\n          className=\"cursor-grab active:cursor-grabbing p-1 hover:bg-muted rounded\"\n          onClick={(e) => e.stopPropagation()}\n        >\n          <GripVertical className=\"size-4 shrink-0 text-muted-foreground\" />\n        </div>\n        <span className=\"capitalize\">{column.id}</span>\n      </div>\n      {isVisible ? (\n        <CircleCheckBig className=\"size-4 shrink-0\" />\n      ) : (\n        <Circle className=\"size-4 shrink-0\" />\n      )}\n    </CommandItem>\n  )\n}\n\nexport function DataTableViewOptions<TData>({\n  table,\n}: {\n  table: Table<TData>\n}) {\n  const [open, setOpen] = useState(false)\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  )\n\n  // Get all hideable columns\n  const hideableColumns = table\n    .getAllColumns()\n    .filter(\n      (column) =>\n        typeof column.accessorFn !== \"undefined\" && column.getCanHide()\n    )\n\n  // Get current column order or use the original order\n  const currentOrder = table.getState().columnOrder\n  const orderedColumns = currentOrder.length > 0 \n    ? currentOrder\n        .map(id => hideableColumns.find(col => col.id === id))\n        .filter((c): c is NonNullable<typeof c> => c !== undefined)\n        .concat(hideableColumns.filter(col => !currentOrder.includes(col.id)))\n    : hideableColumns\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event\n\n    if (over && active.id !== over.id) {\n      const oldIndex = orderedColumns.findIndex((col) => col?.id === active.id)\n      const newIndex = orderedColumns.findIndex((col) => col?.id === over.id)\n\n      if (oldIndex !== -1 && newIndex !== -1) {\n        const newOrderedColumns = arrayMove(orderedColumns, oldIndex, newIndex)\n        const newColumnOrder = newOrderedColumns.map(col => col!.id)\n        \n        const allColumnIds = table.getAllColumns().map(col => col.id)\n        const hideableColumnIds = hideableColumns.map(col => col.id)\n\n        const currentFullOrder = table.getState().columnOrder.length > 0\n          ? table.getState().columnOrder\n          : allColumnIds\n\n        let hideableIndex = 0\n        const newFullOrder = currentFullOrder.map(id => {\n          if (hideableColumnIds.includes(id)) {\n            return newColumnOrder[hideableIndex++]\n          }\n          return id\n        })\n\n        table.setColumnOrder(newFullOrder)\n      }\n    }\n  }\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          className=\"flex ml-auto\"\n        >\n          <Settings2 />\n          View\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[200px] p-0\" align=\"end\">\n        <Command>\n          <CommandInput placeholder=\"Search columns...\" />\n          <CommandList>\n            <CommandEmpty>No columns found.</CommandEmpty>\n            <CommandGroup>\n              <DndContext\n                sensors={sensors}\n                collisionDetection={closestCenter}\n                onDragEnd={handleDragEnd}\n              >\n                <SortableContext\n                  items={orderedColumns.map(col => col!.id)}\n                  strategy={verticalListSortingStrategy}\n                >\n                  {orderedColumns.map((column) => {\n                     if (!column) return null\n                     const isVisible = column.getIsVisible()\n                     return (\n                       <SortableItem<TData>\n                         key={column.id}\n                         id={column.id}\n                         column={column}\n                         isVisible={isVisible}\n                         onToggleVisibility={() => column.toggleVisibility(!isVisible)}\n                       />\n                     )\n                   })}\n                </SortableContext>\n              </DndContext>\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table-basic/data-table-view-options.tsx"
    },
    {
      "path": "registry/data-table-basic/lib/data-table.ts",
      "content": "import type { RowData } from \"@tanstack/react-table\";\nimport type { ColumnFiltersState, PaginationState, SortingState, VisibilityState, ColumnOrderState } from \"@tanstack/react-table\";\n\nexport type DataTableConfig = typeof dataTableConfig;\n\nexport const dataTableConfig = {\n  textOperators: [\n    { label: \"Contains\", value: \"iLike\" as const },\n    { label: \"Does not contain\", value: \"notILike\" as const },\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  numericOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is less than\", value: \"lt\" as const },\n    { label: \"Is greater than\", value: \"gt\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  dateOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is before\", value: \"lt\" as const },\n    { label: \"Is after\", value: \"gt\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  selectOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  multiSelectOperators: [\n    { label: \"Has any of\", value: \"inArray\" as const },\n    { label: \"Has none of\", value: \"notInArray\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  booleanOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n  ],\n  filterVariants: [\n    \"text\", \"number\", \"range\", \"date\", \"dateRange\", \"boolean\", \"select\", \"multiSelect\"\n  ] as const,\n  operators: [\n    \"iLike\", \"notILike\", \"eq\", \"ne\", \"inArray\", \"notInArray\", \n    \"isEmpty\", \"isNotEmpty\", \"lt\", \"gt\", \"isBetween\"\n  ] as const,\n}; \n\n// URL Search Parameters Types\nexport interface SearchParams {\n  [key: string]: string | string[] | undefined;\n}\n\nexport interface DataTableSearchParams {\n  page?: string;\n  pageSize?: string;\n  sort?: string;\n  filters?: string;\n  visibility?: string;\n  order?: string;\n}\n\nexport interface DataTableState {\n  pagination: PaginationState;\n  sorting: SortingState;\n  columnFilters: ColumnFiltersState;\n  columnVisibility: VisibilityState;\n  columnOrder: ColumnOrderState;\n}\n\n// Utility Functions for URL Search Parameters\nexport function parseSearchParams(searchParams: SearchParams): Partial<DataTableState> {\n  const state: Partial<DataTableState> = {};\n\n  // Parse pagination\n  const page = searchParams.page ? parseInt(searchParams.page as string) - 1 : 0;\n  const pageSize = searchParams.pageSize ? parseInt(searchParams.pageSize as string) : 10;\n  state.pagination = {\n    pageIndex: Math.max(0, page),\n    pageSize: Math.max(1, pageSize),\n  };\n\n  // Parse sorting\n  if (searchParams.sort) {\n    try {\n      const sortString = searchParams.sort as string;\n      state.sorting = sortString.split(',').map(sort => {\n        const [id, desc] = sort.split(':');\n        return {\n          id,\n          desc: desc === 'desc'\n        };\n      });\n    } catch {\n      state.sorting = [];\n    }\n  } else {\n    state.sorting = [];\n  }\n\n  // Parse filters\n  if (searchParams.filters) {\n    try {\n      const filtersString = decodeURIComponent(searchParams.filters as string);\n      state.columnFilters = JSON.parse(filtersString);\n    } catch {\n      state.columnFilters = [];\n    }\n  } else {\n    state.columnFilters = [];\n  }\n\n  // Parse column visibility\n  if (searchParams.visibility) {\n    try {\n      const visibilityString = decodeURIComponent(searchParams.visibility as string);\n      state.columnVisibility = JSON.parse(visibilityString);\n    } catch {\n      state.columnVisibility = {};\n    }\n  } else {\n    state.columnVisibility = {};\n  }\n\n  // Parse column order\n  if (searchParams.order) {\n    try {\n      state.columnOrder = (searchParams.order as string).split(\",\");\n    } catch {\n      state.columnOrder = [];\n    }\n  } else {\n    state.columnOrder = [];\n  }\n\n  return state;\n}\n\nexport function serializeTableState(state: DataTableState): DataTableSearchParams {\n  const params: DataTableSearchParams = {};\n\n  // Serialize pagination\n  if (state.pagination.pageIndex > 0) {\n    params.page = (state.pagination.pageIndex + 1).toString();\n  }\n  if (state.pagination.pageSize !== 10) {\n    params.pageSize = state.pagination.pageSize.toString();\n  }\n\n  // Serialize sorting\n  if (state.sorting.length > 0) {\n    params.sort = state.sorting\n      .map(sort => `${sort.id}:${sort.desc ? 'desc' : 'asc'}`)\n      .join(',');\n  }\n\n  // Serialize filters\n  if (state.columnFilters.length > 0) {\n    params.filters = encodeURIComponent(JSON.stringify(state.columnFilters));\n  }\n\n  // Serialize column visibility (only if columns are hidden)\n  const hiddenColumns = Object.entries(state.columnVisibility).filter(([, visible]) => !visible);\n  if (hiddenColumns.length > 0) {\n    params.visibility = encodeURIComponent(JSON.stringify(state.columnVisibility));\n  }\n\n  // Serialize column order\n  if (state.columnOrder?.length > 0) {\n    params.order = state.columnOrder.join(\",\");\n  }\n\n  return params;\n}\n\nexport function updateSearchParams(\n  currentParams: URLSearchParams,\n  newParams: DataTableSearchParams\n): URLSearchParams {\n  const updatedParams = new URLSearchParams(currentParams);\n\n  // Remove existing data table params\n  updatedParams.delete('page');\n  updatedParams.delete('pageSize');\n  updatedParams.delete('sort');\n  updatedParams.delete('filters');\n  updatedParams.delete('visibility');\n  updatedParams.delete('order');\n\n  // Add new params\n  Object.entries(newParams).forEach(([key, value]) => {\n    if (value !== undefined && value !== '') {\n      updatedParams.set(key, value);\n    }\n  });\n\n  return updatedParams;\n}\n\ndeclare module \"@tanstack/react-table\" {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface ColumnMeta<TData extends RowData, TValue> {\n    label?: string;\n    placeholder?: string;\n    variant?: FilterVariant;\n    fieldType?: \"text\" | \"email\" | \"number\" | \"select\" | \"date\" | \"boolean\";\n    options?: Option[];\n    range?: [number, number];\n    unit?: string;\n    icon?: React.FC<React.SVGProps<SVGSVGElement>>;\n    excludeFromForm?: boolean;\n    readOnly?: boolean;\n  }\n}\n\nexport interface Option {\n  label: string;\n  value: string;\n  count?: number;\n  icon?: React.FC<React.SVGProps<SVGSVGElement>>;\n}\n\nexport type FilterOperator = DataTableConfig[\"operators\"][number];\nexport type FilterVariant = DataTableConfig[\"filterVariants\"][number];\n\nexport interface ExtendedColumnFilter<TData> {\n  id: Extract<keyof TData, string>;\n  value: string | string[] | number | boolean | Date;\n  variant: FilterVariant;\n  operator: FilterOperator;\n  filterId: string;\n}\n\n// Custom filter function that handles all our operators\nexport function customFilterFn(row: { getValue: (key: string) => unknown }, columnId: string, filterValue: { operator: string; value: unknown; variant: string }) {\n  if (!filterValue || typeof filterValue !== 'object') return true;\n  \n  const { operator, value, variant } = filterValue;\n  const cellValue = row.getValue(columnId);\n\n  // Handle empty/not empty operators first\n  if (operator === \"isEmpty\") {\n    return cellValue === null || cellValue === undefined || cellValue === \"\";\n  }\n  if (operator === \"isNotEmpty\") {\n    return cellValue !== null && cellValue !== undefined && cellValue !== \"\";\n  }\n\n  // If no value provided for other operators, don't filter\n  if (value === null || value === undefined || value === \"\") return true;\n\n  // Convert values for comparison\n  let compareValue = value;\n  \n  // Convert string numbers to actual numbers for numeric operations\n  if (variant === \"number\" && typeof value === \"string\" && value !== \"\") {\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue)) {\n      compareValue = numValue;\n    }\n  }\n  \n  // Convert date strings to Date objects for date operations\n  if (variant === \"date\" && typeof value === \"string\" && value !== \"\") {\n    compareValue = new Date(value);\n  }\n  \n  // Convert string booleans to actual booleans\n  if (variant === \"boolean\" && typeof value === \"string\") {\n    compareValue = value === \"true\";\n  }\n\n  // Handle different operators\n  switch (operator) {\n    case \"eq\": // Is\n      // Handle date comparisons for equality\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          // Compare dates by day (ignore time)\n          return cellDate.toDateString() === compareDate.toDateString();\n        }\n      }\n      return cellValue === compareValue;\n      \n    case \"ne\": // Is not\n      // Handle date comparisons for inequality\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          // Compare dates by day (ignore time)\n          return cellDate.toDateString() !== compareDate.toDateString();\n        }\n      }\n      return cellValue !== compareValue;\n      \n    case \"iLike\": // Contains (case insensitive)\n      if (typeof cellValue === \"string\" && typeof compareValue === \"string\") {\n        return cellValue.toLowerCase().includes(compareValue.toLowerCase());\n      }\n      return false;\n      \n    case \"notILike\": // Does not contain (case insensitive)\n      if (typeof cellValue === \"string\" && typeof compareValue === \"string\") {\n        return !cellValue.toLowerCase().includes(compareValue.toLowerCase());\n      }\n      return true;\n      \n    case \"lt\": // Less than / Before\n      if (typeof cellValue === \"number\" && typeof compareValue === \"number\") {\n        return cellValue < compareValue;\n      }\n      // Handle date comparisons\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          return cellDate < compareDate;\n        }\n      }\n      if (cellValue instanceof Date && compareValue instanceof Date) {\n        return cellValue < compareValue;\n      }\n      return false;\n      \n    case \"gt\": // Greater than / After\n      if (typeof cellValue === \"number\" && typeof compareValue === \"number\") {\n        return cellValue > compareValue;\n      }\n      // Handle date comparisons\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          return cellDate > compareDate;\n        }\n      }\n      if (cellValue instanceof Date && compareValue instanceof Date) {\n        return cellValue > compareValue;\n      }\n      return false;\n      \n    case \"inArray\": // Has any of (for multi-select)\n      if (Array.isArray(compareValue)) {\n        return compareValue.includes(cellValue);\n      }\n      return false;\n      \n    case \"notInArray\": // Has none of (for multi-select)\n      if (Array.isArray(compareValue)) {\n        return !compareValue.includes(cellValue);\n      }\n      return true;\n      \n    case \"isBetween\": // Is between (for ranges)\n      if (Array.isArray(value) && value.length === 2) {\n        const [min, max] = value;\n        const minNum = typeof min === \"string\" ? parseFloat(min) : min;\n        const maxNum = typeof max === \"string\" ? parseFloat(max) : max;\n        \n        if (typeof cellValue === \"number\" && !isNaN(minNum as number) && !isNaN(maxNum as number)) {\n          return cellValue >= (minNum as number) && cellValue <= (maxNum as number);\n        }\n      }\n      return true;\n      \n    default:\n      return true;\n  }\n} ",
      "type": "registry:lib",
      "target": "lib/data-table.ts"
    },
    {
      "path": "registry/data-table-basic/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/client.ts"
    },
    {
      "path": "registry/data-table-basic/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/server.ts"
    },
    {
      "path": "registry/data-table-basic/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { NextResponse, type NextRequest } from 'next/server'\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll()\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\n          supabaseResponse = NextResponse.next({\n            request,\n          })\n          cookiesToSet.forEach(({ name, value, options }) =>\n            supabaseResponse.cookies.set(name, value, options)\n          )\n        },\n      },\n    }\n  )\n\n  // Do not run code between createServerClient and\n  // supabase.auth.getUser(). A simple mistake could make it very hard to debug\n  // issues with users being randomly logged out.\n\n  // IMPORTANT: DO NOT REMOVE auth.getUser()\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  if (\n    !user &&\n    !request.nextUrl.pathname.startsWith('/login') &&\n    !request.nextUrl.pathname.startsWith('/auth')\n  ) {\n    // no user, potentially respond by redirecting the user to the login page\n    const url = request.nextUrl.clone()\n    url.pathname = '/auth/login'\n    return NextResponse.redirect(url)\n  }\n\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\n  // If you're creating a new response object with NextResponse.next() make sure to:\n  // 1. Pass the request in it, like so:\n  //    const myNewResponse = NextResponse.next({ request })\n  // 2. Copy over the cookies, like so:\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\n  //    the cookies!\n  // 4. Finally:\n  //    return myNewResponse\n  // If this is not done, you may be causing the browser and server to go out\n  // of sync and terminate the user's session prematurely!\n\n  return supabaseResponse\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/middleware.ts"
    },
    {
      "path": "registry/data-table-basic/app/data-table-basic/page.tsx",
      "content": "import { DataTable } from \"@/components/data-table-basic/data-table\"\nimport { columns } from \"./_components/columns-payments\"\nimport { getPayments } from \"./_lib/queries\"\nimport { parseSearchParams } from \"@/lib/data-table\"\nimport { createPayment, updatePayment, deletePayments } from \"./_lib/actions\"\n\n\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const params = await searchParams\n  const tableState = parseSearchParams(params)\n  const page = (tableState.pagination?.pageIndex ?? 0) + 1 // Convert 0-based to 1-based\n  const pageSize = tableState.pagination?.pageSize ?? 10\n  const sorting = tableState.sorting ?? []\n\n  const { data: payments, totalCount } = await getPayments(page, pageSize, sorting)\n \n  return (\n    <div className=\"container mx-auto py-10\">\n      <DataTable \n        columns={columns} \n        data={payments} \n        searchParams={params}\n        totalCount={totalCount}\n        createAction={createPayment}\n        updateAction={updatePayment}\n        deleteAction={deletePayments}\n      />\n    </div>\n  )\n}",
      "type": "registry:page",
      "target": "app/data-table-basic/page.tsx"
    },
    {
      "path": "registry/data-table-basic/app/data-table-basic/_components/columns-payments.tsx",
      "content": "\"use client\"\n\nimport { ColumnDef } from \"@tanstack/react-table\"\nimport { Payment } from \"../_lib/types\"\nimport { DataTableColumnHeader } from \"@/components/data-table-basic/data-table-column-header\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\n\nexport const columns: ColumnDef<Payment>[] = [\n  {\n    id: \"select\",\n    header: ({ table }) => (\n      <Checkbox\n        checked={\n          table.getIsAllPageRowsSelected() ||\n          (table.getIsSomePageRowsSelected() && \"indeterminate\")\n        }\n        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n        aria-label=\"Select all\"\n      />\n    ),\n    cell: ({ row }) => (\n      <Checkbox\n        checked={row.getIsSelected()}\n        onCheckedChange={(value) => row.toggleSelected(!!value)}\n        aria-label=\"Select row\"\n      />\n    ),\n    enableSorting: false,\n    enableHiding: false,\n    size: 40,\n  },\n  {\n    accessorKey: \"status\",\n    header: ({ column }) => (\n      <DataTableColumnHeader column={column} title=\"Status\" />\n    ),\n    meta: {\n      label: \"Status\",\n      fieldType: \"select\",\n      options: [\n        { label: \"Pending\", value: \"pending\" },\n        { label: \"Processing\", value: \"processing\" },\n        { label: \"Success\", value: \"success\" },\n        { label: \"Failed\", value: \"failed\" },\n      ],\n    },\n  },\n  {\n    accessorKey: \"email\",\n    header: ({ column }) => (\n      <DataTableColumnHeader column={column} title=\"Email\" />\n    ),\n    meta: {\n      label: \"Email\",\n      fieldType: \"email\",\n      placeholder: \"user@example.com\",\n    },\n  },\n  {\n    accessorKey: \"amount\",\n    header: ({ column }) => (\n      <DataTableColumnHeader column={column} title=\"Amount\" />\n    ),\n    meta: {\n      label: \"Amount\",\n      fieldType: \"number\",\n    },\n  },\n]",
      "type": "registry:component",
      "target": "app/data-table-basic/_components/columns-payments.tsx"
    },
    {
      "path": "registry/data-table-basic/app/data-table-basic/_lib/actions.ts",
      "content": "\"use server\"\n\nimport { createClient } from '@/lib/supabase/server'\nimport { revalidatePath } from 'next/cache'\nimport { Payment } from './types'\n\nexport async function deletePayments(ids: string[]): Promise<{ \n  success: boolean; \n  error?: string; \n  deletedCount?: number \n}> {\n  try {\n    const supabase = await createClient()\n    \n    const { error, count } = await supabase\n      .from('my_nextjs_supabase_starter_app_payments_example')\n      .delete({ count: 'exact' })\n      .in('id', ids)\n\n    if (error) {\n      console.error('Error deleting payments:', error)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n\n    // Revalidate the page to refresh the data\n    revalidatePath('/test/table-basic')\n\n    return {\n      success: true,\n      deletedCount: count || 0\n    }\n  } catch (error) {\n    console.error('Unexpected error deleting payments:', error)\n    return {\n      success: false,\n      error: 'An unexpected error occurred while deleting payments'\n    }\n  }\n}\n\nexport async function createPayment(data: Partial<Payment>): Promise<{ \n  success: boolean; \n  error?: string; \n  data?: Payment;\n}> {\n  try {\n    // Validate required fields\n    if (!data.amount || !data.status || !data.email) {\n      return {\n        success: false,\n        error: 'Missing required fields: amount, status, and email are required'\n      }\n    }\n\n    const supabase = await createClient()\n    \n    // Create the insert data without the id field\n    const insertData = {\n      amount: data.amount,\n      status: data.status,\n      email: data.email\n    }\n    \n    const { data: result, error } = await supabase\n      .from('my_nextjs_supabase_starter_app_payments_example')\n      .insert([insertData])\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error creating payment:', error)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n\n    // Revalidate the page to refresh the data\n    revalidatePath('/test/table-basic')\n\n    return {\n      success: true,\n      data: result\n    }\n  } catch (error) {\n    console.error('Unexpected error creating payment:', error)\n    return {\n      success: false,\n      error: 'An unexpected error occurred while creating payment'\n    }\n  }\n}\n\nexport async function updatePayment(\n  id: string,\n  data: Partial<Payment>\n): Promise<{ \n  success: boolean; \n  error?: string; \n  data?: Payment;\n}> {\n  try {\n    const supabase = await createClient()\n    \n    // Filter out the id field to prevent updating identity column\n    const updateData = { ...data }\n    delete updateData.id\n    \n    const { data: result, error } = await supabase\n      .from('my_nextjs_supabase_starter_app_payments_example')\n      .update(updateData)\n      .eq('id', id)\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error updating payment:', error)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n\n    // Revalidate the page to refresh the data\n    revalidatePath('/test/table-basic')\n\n    return {\n      success: true,\n      data: result\n    }\n  } catch (error) {\n    console.error('Unexpected error updating payment:', error)\n    return {\n      success: false,\n      error: 'An unexpected error occurred while updating payment'\n    }\n  }\n}\n\nexport async function updatePayments(\n  ids: string[],\n  data: Partial<Payment>\n): Promise<{ \n  success: boolean; \n  error?: string; \n  updatedCount?: number;\n}> {\n  try {\n    const supabase = await createClient()\n    \n    // Filter out the id field to prevent updating identity column\n    const updateData = { ...data }\n    delete updateData.id\n    \n    const { error, count } = await supabase\n      .from('my_nextjs_supabase_starter_app_payments_example')\n      .update(updateData, { count: 'exact' })\n      .in('id', ids)\n\n    if (error) {\n      console.error('Error updating payments:', error)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n\n    // Revalidate the page to refresh the data\n    revalidatePath('/test/table-basic')\n\n    return {\n      success: true,\n      updatedCount: count || 0\n    }\n  } catch (error) {\n    console.error('Unexpected error updating payments:', error)\n    return {\n      success: false,\n      error: 'An unexpected error occurred while updating payments'\n    }\n  }\n}\n",
      "type": "registry:lib",
      "target": "app/data-table-basic/_lib/actions.ts"
    },
    {
      "path": "registry/data-table-basic/app/data-table-basic/_lib/queries.ts",
      "content": "import { createClient } from '@/lib/supabase/server'\nimport { SortingState } from '@tanstack/react-table'\n\nimport { Payment } from \"./types\"\n\nexport async function getPayments(\n  page: number = 1,\n  pageSize: number = 10,\n  sorting: SortingState = []\n): Promise<{ data: Payment[]; totalCount: number }> {\n  const supabase = await createClient()\n  \n  const from = (page - 1) * pageSize\n  const to = from + pageSize - 1\n\n  // Get total count\n  const { count } = await supabase\n    .from('my_nextjs_supabase_starter_app_payments_example')\n    .select('*', { count: 'exact', head: true })\n\n  // Build the query with sorting\n  let query = supabase\n    .from('my_nextjs_supabase_starter_app_payments_example')\n    .select('*')\n    .range(from, to)\n\n  // Apply sorting if provided\n  if (sorting.length > 0) {\n    sorting.forEach((sort) => {\n      query = query.order(sort.id, { ascending: !sort.desc })\n    })\n  } else {\n    // Default sorting by id if no sorting is specified\n    query = query.order('id', { ascending: true })\n  }\n\n  const { data, error } = await query\n\n  if (error) {\n    throw new Error('Failed to fetch payments')\n  }\n\n  return {\n    data: data || [],\n    totalCount: count || 0\n  }\n}",
      "type": "registry:lib",
      "target": "app/data-table-basic/_lib/queries.ts"
    },
    {
      "path": "registry/data-table-basic/app/data-table-basic/_lib/types.ts",
      "content": "export type Payment = {\n    id: string\n    amount: number\n    status: \"pending\" | \"processing\" | \"success\" | \"failed\"\n    email: string\n  }",
      "type": "registry:lib",
      "target": "app/data-table-basic/_lib/types.ts"
    }
  ]
}