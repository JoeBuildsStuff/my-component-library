{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table",
  "type": "registry:block",
  "title": "Data Table",
  "description": "A comprehensive data table component with advanced filtering, sorting, pagination, row editing, and CRUD operations. Includes support for custom forms and Supabase integration.",
  "dependencies": [
    "@tanstack/react-table",
    "@supabase/supabase-js",
    "lucide-react",
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "sonner",
    "next"
  ],
  "registryDependencies": [
    "table",
    "button",
    "input",
    "select",
    "checkbox",
    "badge",
    "popover",
    "command",
    "dropdown-menu",
    "sheet",
    "dialog",
    "alert-dialog",
    "separator",
    "calendar",
    "scroll-area",
    "input-number"
  ],
  "files": [
    {
      "path": "registry/data-table/components/data-table/data-table.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { useRouter, useSearchParams, usePathname } from \"next/navigation\"\nimport {\n  ColumnDef,\n  ColumnFiltersState,\n  SortingState,\n  VisibilityState,\n  flexRender,\n  getCoreRowModel,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n  PaginationState,\n} from \"@tanstack/react-table\"\n\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\"\n\nimport { DataTablePagination } from \"./data-table-pagination\"\nimport DataTableToolbar from \"./data-table-toolbar\"\nimport { \n  DataTableState, \n  serializeTableState, \n  updateSearchParams \n} from \"@/lib/data-table\"\n\n/**\n * Props for the DataTable component\n */\nexport interface DataTableProps {\n  /** Array of column definitions that define the table structure */\n  columns: ColumnDef<Record<string, unknown>, unknown>[]\n  /** Array of data objects to display in the table */\n  data: Record<string, unknown>[]\n  /** Initial state for the table including pagination, sorting, filters, etc. */\n  initialState?: Partial<DataTableState>\n  /** Total number of pages for server-side pagination */\n  pageCount?: number\n  /** Function to handle multi deletion of rows */\n  deleteAction?: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  /** Function to handle creation of new rows */\n  createAction?: (data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  /** Function to handle updating existing rows */\n  updateActionSingle?: (id: string, data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  /** Function to handle multi updating of multiple rows */\n  updateActionMulti?: (ids: string[], data: Record<string, unknown>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  /** Custom form component for adding new rows */\n  customAddForm?: React.ComponentType<{\n    onSuccess?: () => void\n    onCancel?: () => void\n    createAction?: (data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  }>\n  /** Custom form component for editing existing rows */\n  customEditFormSingle?: React.ComponentType<{\n    data: Record<string, unknown>\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateAction?: (id: string, data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  }>\n  /** Custom form component for multi editing multiple rows */\n  customEditFormMulti?: React.ComponentType<{\n    selectedCount: number\n    onSuccess?: () => void\n    onCancel?: () => void\n    multiUpdateAction?: (ids: string[], data: Record<string, unknown>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  }>\n}\n\ninterface DataTableInternalProps<TData, TValue> {\n  columns: ColumnDef<TData, TValue>[]\n  data: TData[]\n  initialState?: Partial<DataTableState>\n  pageCount?: number\n  deleteAction?: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateActionSingle?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateActionMulti?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  customAddForm?: React.ComponentType<{\n    onSuccess?: () => void\n    onCancel?: () => void\n    createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n  customEditFormSingle?: React.ComponentType<{\n    data: TData\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateAction?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n  customEditFormMulti?: React.ComponentType<{\n    selectedCount: number\n    onSuccess?: () => void\n    onCancel?: () => void\n    multiUpdateAction?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  }>\n}\n\nexport function DataTable<TData, TValue>({\n  columns,\n  data,\n  initialState,\n  pageCount,\n  deleteAction,\n  createAction,\n  updateActionSingle,\n  updateActionMulti,\n  customAddForm,\n  customEditFormSingle,\n  customEditFormMulti,\n}: DataTableInternalProps<TData, TValue>) {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  const [sorting, setSorting] = React.useState<SortingState>(\n    initialState?.sorting ?? []\n  )\n  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(\n    initialState?.columnFilters ?? []\n  )\n  const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>(\n    initialState?.columnVisibility ?? {}\n  )\n  const [rowSelection, setRowSelection] = React.useState({})\n  const [pagination, setPagination] = React.useState<PaginationState>(\n    initialState?.pagination ?? { pageIndex: 0, pageSize: 10 }\n  )\n  const [columnOrder, setColumnOrder] = React.useState<string[]>(\n    initialState?.columnOrder ?? []\n  )\n\n  // Sync state changes to URL\n  React.useEffect(() => {\n    const currentState: DataTableState = {\n      pagination,\n      sorting,\n      columnFilters,\n      columnVisibility,\n      columnOrder,\n    }\n\n    const newParams = serializeTableState(currentState)\n    const updatedSearchParams = updateSearchParams(searchParams, newParams)\n    \n    // Only update URL if parameters actually changed\n    const currentUrl = `${pathname}?${searchParams.toString()}`\n    const newUrl = `${pathname}?${updatedSearchParams.toString()}`\n    \n    if (currentUrl !== newUrl) {\n      router.replace(newUrl, { scroll: false })\n    }\n  }, [pagination, sorting, columnFilters, columnVisibility, columnOrder, router, pathname, searchParams])\n\n  const table = useReactTable({\n    data,\n    columns,\n    pageCount: pageCount ?? -1,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    onSortingChange: setSorting,\n    getSortedRowModel: getSortedRowModel(),\n    onColumnFiltersChange: setColumnFilters,\n    getFilteredRowModel: getFilteredRowModel(),\n    onColumnVisibilityChange: setColumnVisibility,\n    onRowSelectionChange: setRowSelection,\n    onPaginationChange: setPagination,\n    onColumnOrderChange: setColumnOrder,\n    enableMultiSort: true,\n    manualPagination: true,\n    manualFiltering: true,\n    manualSorting: true,\n    state: {\n      sorting,\n      columnFilters,\n      columnVisibility,\n      rowSelection,\n      pagination,\n      columnOrder,\n    },\n  })\n\n  return (\n    <div className=\"\">\n        <div className=\"pb-2 \">\n            <DataTableToolbar \n              table={table} \n              deleteAction={deleteAction} \n              createAction={createAction}\n              updateActionSingle={updateActionSingle}\n              updateActionMulti={updateActionMulti}\n              customAddForm={customAddForm}\n              customEditFormSingle={customEditFormSingle}\n              customEditFormMulti={customEditFormMulti}\n            />\n        </div>\n\n        <div className=\"rounded-md border\">\n            <Table>\n                <TableHeader>\n                {table.getHeaderGroups().map((headerGroup) => (\n                    <TableRow key={headerGroup.id}>\n                    {headerGroup.headers.map((header) => {\n                        return (\n                        <TableHead key={header.id}>\n                            {header.isPlaceholder\n                            ? null\n                            : flexRender(\n                                header.column.columnDef.header,\n                                header.getContext()\n                                )}\n                        </TableHead>\n                        )\n                    })}\n                    </TableRow>\n                ))}\n                </TableHeader>\n                <TableBody>\n                {table.getRowModel().rows?.length ? (\n                    table.getRowModel().rows.map((row) => (\n                    <TableRow\n                        key={row.id}\n                        data-state={row.getIsSelected() && \"selected\"}\n                    >\n                        {row.getVisibleCells().map((cell) => (\n                        <TableCell key={cell.id}>\n                            {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                        </TableCell>\n                        ))}\n                    </TableRow>\n                    ))\n                ) : (\n                    <TableRow>\n                    <TableCell colSpan={columns.length} className=\"h-24 text-center\">\n                        No results.\n                    </TableCell>\n                    </TableRow>\n                )}\n                </TableBody>\n            </Table>\n        </div>\n        \n        <div className=\"pt-2\">\n            <DataTablePagination table={table} />\n        </div>\n    </div>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-column-header.tsx",
      "content": "import { Column } from \"@tanstack/react-table\"\nimport { ArrowDown, ArrowUp, ChevronsUpDown, EyeOff } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\n\ninterface DataTableColumnHeaderProps<TData, TValue>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  column: Column<TData, TValue>\n  title: string\n}\n\nexport function DataTableColumnHeader<TData, TValue>({\n  column,\n  title,\n  className,\n}: DataTableColumnHeaderProps<TData, TValue>) {\n  if (!column.getCanSort()) {\n    return <div className={cn(className)}>{title}</div>\n  }\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"data-[state=open]:bg-accent -ml-3 h-8\"\n          >\n            <span>{title}</span>\n            {column.getIsSorted() === \"desc\" ? (\n              <ArrowDown />\n            ) : column.getIsSorted() === \"asc\" ? (\n              <ArrowUp />\n            ) : (\n              <ChevronsUpDown />\n            )}\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"start\">\n          <DropdownMenuItem onClick={() => column.toggleSorting(false)}>\n            <ArrowUp />\n            Asc\n          </DropdownMenuItem>\n          <DropdownMenuItem onClick={() => column.toggleSorting(true)}>\n            <ArrowDown />\n            Desc\n          </DropdownMenuItem>\n          <DropdownMenuSeparator />\n          <DropdownMenuItem onClick={() => column.toggleVisibility(false)}>\n            <EyeOff />\n            Hide\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-column-header.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-filter.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { ListFilter, Plus, ChevronRight } from \"lucide-react\";\nimport DataTableFilterItem from \"./data-table-filter-item\";\nimport { useState, useEffect } from \"react\";\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  DragEndEvent,\n} from \"@dnd-kit/core\";\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { Table } from \"@tanstack/react-table\";\nimport type { ExtendedColumnFilter, FilterVariant, FilterOperator } from \"@/lib/data-table\";\n\n// Generate a random ID\nfunction generateId(length: number = 8): string {\n  return Math.random().toString(36).substring(2, 2 + length);\n}\n\nexport default function DataTableFilter<TData>({ table }: { table: Table<TData> }) {\n  const [filters, setFilters] = useState<ExtendedColumnFilter<TData>[]>([]);\n  const [logicalOperator, setLogicalOperator] = useState<\"and\" | \"or\">(\"and\");\n  const [open, setOpen] = useState(false);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Sync filters with table's column filters state\n  useEffect(() => {\n    const currentFilters = table.getState().columnFilters;\n    if (currentFilters.length > 0) {\n      const newFilters: ExtendedColumnFilter<TData>[] = currentFilters.map((filter, index) => {\n        // Get column metadata to determine variant\n        const column = table.getColumn(filter.id);\n        const columnMeta = column?.columnDef.meta;\n        const variant: FilterVariant = columnMeta?.variant ?? \"text\";\n        \n        // Extract filter details from the value object\n        const filterValue = filter.value as { operator?: string; value?: unknown; variant?: string } | undefined;\n        const operator = filterValue?.operator ?? \"iLike\";\n        const value = filterValue?.value ?? \"\";\n\n        return {\n          filterId: `${filter.id}-${index}`, // Create unique ID\n          id: filter.id as Extract<keyof TData, string>,\n          value: value as string | number | boolean | string[] | Date,\n          operator: operator as FilterOperator,\n          variant: variant,\n        };\n      });\n      setFilters(newFilters);\n    } else {\n      // If no filters are applied, show one empty filter item\n      setFilters([\n        {\n          filterId: generateId(),\n          id: \"\" as Extract<keyof TData, string>,\n          value: \"\",\n          operator: \"iLike\",\n          variant: \"text\",\n        },\n      ]);\n    }\n  }, [table.getState().columnFilters]);\n\n  const addFilter = () => {\n    const newFilter: ExtendedColumnFilter<TData> = {\n      filterId: generateId(),\n      id: \"\" as Extract<keyof TData, string>,\n      value: \"\",\n      operator: \"iLike\",\n      variant: \"text\",\n    };\n    setFilters([...filters, newFilter]);\n  };\n\n  const removeFilter = (filterId: string) => {\n    setFilters(filters.filter((f) => f.filterId !== filterId));\n  };\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n    if (over && active.id !== over.id) {\n      setFilters((items) => {\n        const oldIndex = items.findIndex((item) => item.filterId === active.id);\n        const newIndex = items.findIndex((item) => item.filterId === over.id);\n        return arrayMove(items, oldIndex, newIndex);\n      });\n    }\n  };\n\n  const updateFilter = (filterId: string, newFilter: ExtendedColumnFilter<TData>) => {\n    setFilters(\n      filters.map((f) => (f.filterId === filterId ? newFilter : f))\n    );\n  };\n\n  const applyFilters = () => {\n    // Get valid filters (those with column selected and either have value or are empty/not empty operators)\n    const validFilters = filters.filter((f) => \n      f.id && f.operator && (\n        (f.value !== \"\" && f.value !== null && f.value !== undefined) || \n        [\"isEmpty\", \"isNotEmpty\"].includes(f.operator)\n      )\n    );\n\n    // Convert to TanStack table format with custom filter functions\n    const columnFilters = validFilters.map((filter) => {\n      return {\n        id: filter.id as string,\n        value: {\n          operator: filter.operator,\n          value: filter.value,\n          variant: filter.variant\n        }\n      };\n    });\n    \n    table.setColumnFilters(columnFilters);\n    setOpen(false); // Close the popover after applying filters\n  };\n\n  // Get the actual number of applied filters from the table state\n  const appliedFilterCount = table.getState().columnFilters.length;\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button variant=\"outline\">\n          <ListFilter className=\"h-4 w-4\" />\n          <div>Filter</div>\n          <Badge variant=\"secondary\">\n            {appliedFilterCount}\n          </Badge>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"start\" className=\"w-fit p-3\">\n        <div className=\"flex w-full flex-col gap-3\">\n          <p className=\"text-sm font-medium text-muted-foreground\">\n            Filter by:\n          </p>\n          <DndContext\n            sensors={sensors}\n            collisionDetection={closestCenter}\n            onDragEnd={handleDragEnd}\n          >\n            <SortableContext\n              items={filters.map((item) => item.filterId)}\n              strategy={verticalListSortingStrategy}\n            >\n              <div className=\"flex flex-col gap-3\">\n                {filters.map((filter, index) => (\n                  <DataTableFilterItem\n                    key={filter.filterId}\n                    table={table}\n                    filter={filter}\n                    onFilterChange={(newFilter) => updateFilter(filter.filterId, newFilter)}\n                    onRemove={() => removeFilter(filter.filterId)}\n                    index={index}\n                    logicalOperator={logicalOperator}\n                    onLogicalOperatorChange={setLogicalOperator}\n                  />\n                ))}\n              </div>\n            </SortableContext>\n          </DndContext>\n\n          <Separator />\n\n          <div className=\"flex flex-row items-center justify-between gap-3\">\n            <Button\n              variant=\"secondary\"\n              className=\"flex flex-row items-center h-8\"\n              onClick={addFilter}\n            >\n              <Plus className=\"h-4 w-4\" />\n              Add\n            </Button>\n            <Button\n              variant=\"default\"\n              className=\"flex flex-row items-center h-8\"\n              onClick={applyFilters}\n            >\n              Apply\n              <ChevronRight className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-filter.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-filter-item.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { Calendar } from \"@/components/ui/calendar\"\nimport { CalendarDays, ChevronsUpDown, GripVertical, X } from \"lucide-react\"\nimport { useState } from \"react\"\nimport { useSortable } from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { Table } from \"@tanstack/react-table\"\nimport { cn } from \"@/lib/utils\"\nimport { dataTableConfig } from \"@/lib/data-table\"\nimport type { ExtendedColumnFilter, FilterVariant, FilterOperator } from \"@/lib/data-table\"\nimport { InputNumber } from \"@/components/ui/input-number\"\n\n// Format date utility\nfunction formatDate(\n  date: Date | string | number | undefined,\n  opts: Intl.DateTimeFormatOptions = {},\n) {\n  if (!date) return \"\";\n\n  try {\n    return new Intl.DateTimeFormat(\"en-US\", {\n      month: opts.month ?? \"long\",\n      day: opts.day ?? \"numeric\", \n      year: opts.year ?? \"numeric\",\n      ...opts,\n    }).format(new Date(date));\n  } catch {\n    return \"\";\n  }\n}\n\n// Get filter operators for a specific variant\nfunction getFilterOperators(filterVariant: FilterVariant) {\n  const operatorMap: Record<FilterVariant, { label: string; value: FilterOperator }[]> = {\n    text: dataTableConfig.textOperators,\n    number: dataTableConfig.numericOperators,\n    range: dataTableConfig.numericOperators,\n    date: dataTableConfig.dateOperators,\n    dateRange: dataTableConfig.dateOperators,\n    boolean: dataTableConfig.booleanOperators,\n    select: dataTableConfig.selectOperators,\n    multiSelect: dataTableConfig.multiSelectOperators,\n  };\n\n  return operatorMap[filterVariant] ?? dataTableConfig.textOperators;\n}\n\n// Get default filter operator for a variant\nfunction getDefaultFilterOperator(filterVariant: FilterVariant): FilterOperator {\n  const operators = getFilterOperators(filterVariant);\n  return operators[0]?.value ?? \"iLike\";\n}\n\ninterface DataTableFilterItemProps<TData> {\n  table: Table<TData>\n  filter: ExtendedColumnFilter<TData>\n  onFilterChange: (filter: ExtendedColumnFilter<TData>) => void\n  onRemove: () => void\n  index: number\n  logicalOperator: \"and\" | \"or\"\n  onLogicalOperatorChange: (value: \"and\" | \"or\") => void\n}\n\nexport default function DataTableFilterItem<TData>({\n  table,\n  filter,\n  onFilterChange,\n  onRemove,\n  index,\n  logicalOperator,\n  onLogicalOperatorChange,\n}: DataTableFilterItemProps<TData>) {\n  const [columnOpen, setColumnOpen] = useState(false)\n  const [operatorOpen, setOperatorOpen] = useState(false)\n  const [valueOpen, setValueOpen] = useState(false)\n  const [calendarOpen, setCalendarOpen] = useState(false)\n\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id: filter.filterId })\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n  }\n\n  const columns = table\n    .getAllColumns()\n    .filter(\n      (column) =>\n        column.getCanFilter() &&\n        column.id !== \"select\" &&\n        column.id !== \"actions\"\n    )\n\n  const selectedColumn = columns.find((col) => col.id === filter.id)\n  const columnMeta = selectedColumn?.columnDef.meta\n  const filterVariant: FilterVariant = columnMeta?.variant ?? \"text\"\n  const operators = getFilterOperators(filterVariant)\n\n  const renderLogicalOperator = () => {\n    if (index === 0) {\n      return <div className=\"w-16 text-center text-sm font-medium text-muted-foreground\">Where</div>\n    }\n    if (index === 1) {\n      return (\n        <Button\n          variant=\"secondary\"\n          size=\"sm\"\n          className=\"w-16 capitalize\"\n          onClick={() =>\n            onLogicalOperatorChange(logicalOperator === \"and\" ? \"or\" : \"and\")\n          }\n        >\n          {logicalOperator}\n        </Button>\n      )\n    }\n    return <div className=\"w-16 text-center text-sm font-medium text-muted-foreground capitalize\">{logicalOperator}</div>\n  }\n\n  const renderValueInput = () => {\n    const placeholder = columnMeta?.placeholder ?? \"Enter value...\"\n    \n    // Disable input for isEmpty and isNotEmpty operators\n    const isEmptyOperator = [\"isEmpty\", \"isNotEmpty\"].includes(filter.operator)\n    if (isEmptyOperator) {\n      return (\n        <div className=\"w-40 flex items-center justify-center text-sm text-muted-foreground border rounded px-3 py-2\">\n          No value needed\n        </div>\n      )\n    }\n\n    switch (filterVariant) {\n      case \"select\": {\n        const options = columnMeta?.options ?? []\n        return (\n          <Popover open={valueOpen} onOpenChange={setValueOpen}>\n            <PopoverTrigger asChild>\n              <Button variant=\"outline\" className=\"w-40 justify-start\">\n                {filter.value ? \n                  (options.find(option => option.value === filter.value)?.label ?? String(filter.value))\n                  : \"Select value...\"\n                }\n                <ChevronsUpDown className=\"ml-auto h-4 w-4 shrink-0 opacity-50\" />\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-40 p-0\" align=\"start\">\n              <Command>\n                <CommandInput placeholder=\"Search...\" />\n                <CommandList>\n                  <CommandEmpty>No options found.</CommandEmpty>\n                  <CommandGroup>\n                    {options.map((option) => (\n                      <CommandItem\n                        key={option.value}\n                        onSelect={() => {\n                          onFilterChange({ ...filter, value: option.value })\n                          setValueOpen(false)\n                        }}\n                      >\n                        {option.icon && <option.icon className=\"mr-2 h-4 w-4\" />}\n                        {option.label}\n                      </CommandItem>\n                    ))}\n                  </CommandGroup>\n                </CommandList>\n              </Command>\n            </PopoverContent>\n          </Popover>\n        )\n      }\n\n      case \"multiSelect\": {\n        const options = columnMeta?.options ?? []\n        const selectedValues = Array.isArray(filter.value) ? filter.value : []\n        \n        return (\n          <Popover open={valueOpen} onOpenChange={setValueOpen}>\n            <PopoverTrigger asChild>\n              <Button variant=\"outline\" className=\"w-40 justify-start\">\n                {selectedValues.length > 0 ? (\n                  <div className=\"flex flex-wrap gap-1\">\n                    {selectedValues.slice(0, 2).map((value) => (\n                      <Badge key={String(value)} variant=\"secondary\" className=\"text-xs\">\n                        {(options.find(option => option.value === value)?.label ?? String(value))}\n                      </Badge>\n                    ))}\n                    {selectedValues.length > 2 && (\n                      <Badge variant=\"secondary\" className=\"text-xs\">\n                        +{selectedValues.length - 2}\n                      </Badge>\n                    )}\n                  </div>\n                ) : (\n                  \"Select values...\"\n                )}\n                <ChevronsUpDown className=\"ml-auto h-4 w-4 shrink-0 opacity-50\" />\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-40 p-0\" align=\"start\">\n              <Command>\n                <CommandInput placeholder=\"Search...\" />\n                <CommandList>\n                  <CommandEmpty>No options found.</CommandEmpty>\n                  <CommandGroup>\n                    {options.map((option) => (\n                      <CommandItem\n                        key={option.value}\n                        onSelect={() => {\n                          const newValues = selectedValues.includes(option.value)\n                            ? selectedValues.filter(v => v !== option.value)\n                            : [...selectedValues, option.value]\n                          onFilterChange({ ...filter, value: newValues })\n                        }}\n                      >\n                        <Checkbox\n                          checked={selectedValues.includes(option.value)}\n                          className=\"mr-2\"\n                        />\n                        {option.icon && <option.icon className=\"mr-2 h-4 w-4\" />}\n                        {option.label}\n                      </CommandItem>\n                    ))}\n                  </CommandGroup>\n                </CommandList>\n              </Command>\n            </PopoverContent>\n          </Popover>\n        )\n      }\n\n      case \"boolean\": {\n        return (\n          <Select\n            value={filter.value as string}\n            onValueChange={(value) => onFilterChange({ ...filter, value })}\n          >\n            <SelectTrigger className=\"w-40\">\n              <SelectValue placeholder=\"Select...\" />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"true\">True</SelectItem>\n              <SelectItem value=\"false\">False</SelectItem>\n            </SelectContent>\n          </Select>\n        )\n      }\n\n      case \"date\": {\n        const date = filter.value ? new Date(filter.value as string) : undefined\n        return (\n          <Popover open={calendarOpen} onOpenChange={setCalendarOpen}>\n            <PopoverTrigger asChild>\n              <Button\n                variant=\"outline\"\n                className={cn(\n                  \"w-40 justify-start text-left font-normal\",\n                  !date && \"text-muted-foreground\"\n                )}\n              >\n                <CalendarDays className=\"mr-2 h-4 w-4\" />\n                {date ? formatDate(date) : \"Pick a date\"}\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-auto p-0\" align=\"start\">\n              <Calendar\n                mode=\"single\"\n                selected={date}\n                onSelect={(selectedDate) => {\n                  onFilterChange({ \n                    ...filter, \n                    value: selectedDate ? selectedDate.toISOString() : \"\" \n                  })\n                  setCalendarOpen(false)\n                }}\n                initialFocus\n              />\n            </PopoverContent>\n          </Popover>\n        )\n      }\n\n      case \"number\": {\n        const unit = columnMeta?.unit\n        \n        // Handle \"is between\" operator with two inputs\n        if (filter.operator === \"isBetween\") {\n          const values = Array.isArray(filter.value) ? filter.value : [\"\", \"\"]\n          return (\n            <div className=\"flex gap-2 w-80\">\n              <InputNumber\n                value={values[0] || \"\"}\n                onChange={(value) => {\n                  const newValues = [String(value || \"\"), values[1] || \"\"]\n                  onFilterChange({ ...filter, value: newValues })\n                }}\n                placeholder=\"Min\"\n                unit={unit}\n                className=\"flex-1\"\n              />\n              <div className=\"flex items-center text-sm text-muted-foreground\">and</div>\n              <InputNumber\n                value={values[1] || \"\"}\n                onChange={(value) => {\n                  const newValues = [values[0] || \"\", String(value || \"\")]\n                  onFilterChange({ ...filter, value: newValues })\n                }}\n                placeholder=\"Max\"\n                unit={unit}\n                className=\"flex-1\"\n              />\n            </div>\n          )\n        }\n        \n        return (\n          <InputNumber\n            value={filter.value as string}\n            onChange={(value) => onFilterChange({ ...filter, value: String(value || \"\") })}\n            placeholder={placeholder}\n            unit={unit}\n            className=\"w-40\"\n          />\n        )\n      }\n\n      default: {\n        return (\n          <Input\n            placeholder={placeholder}\n            value={filter.value as string}\n            onChange={(e) => onFilterChange({ ...filter, value: e.target.value })}\n            className=\"w-40\"\n          />\n        )\n      }\n    }\n  }\n\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className=\"flex flex-row items-center gap-2\"\n    >\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        {...attributes}\n        {...listeners}\n        className=\"cursor-grab active:cursor-grabbing\"\n      >\n        <GripVertical className=\"h-4 w-4\" />\n      </Button>\n\n      {renderLogicalOperator()}\n\n      <Popover open={columnOpen} onOpenChange={setColumnOpen}>\n        <PopoverTrigger asChild>\n          <Button variant=\"outline\" className=\"w-32 justify-start\">\n            <span className=\"truncate\">\n              {(selectedColumn?.columnDef.meta?.label ?? filter.id) || \"Column\"}\n            </span>\n            <ChevronsUpDown className=\"ml-auto h-4 w-4 shrink-0 opacity-50\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-32 p-0\" align=\"start\">\n          <Command>\n            <CommandInput placeholder=\"Search...\" />\n            <CommandList>\n              <CommandEmpty>No columns found.</CommandEmpty>\n              <CommandGroup>\n                {columns.map((column) => (\n                  <CommandItem\n                    key={column.id}\n                    onSelect={() => {\n                      const newVariant = column.columnDef.meta?.variant ?? \"text\"\n                      const newOperator = getDefaultFilterOperator(newVariant)\n                      onFilterChange({\n                        ...filter,\n                        id: column.id as Extract<keyof TData, string>,\n                        variant: newVariant,\n                        operator: newOperator,\n                        value: \"\",\n                      })\n                      setColumnOpen(false)\n                    }}\n                  >\n                    {(column.columnDef.meta?.label ?? column.id)}\n                  </CommandItem>\n                ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n\n      <Popover open={operatorOpen} onOpenChange={setOperatorOpen}>\n        <PopoverTrigger asChild>\n          <Button variant=\"outline\" className=\"w-32 justify-start\">\n            <span className=\"truncate\">\n              {(operators.find(op => op.value === filter.operator)?.label ?? \"Operator\")}\n            </span>\n            <ChevronsUpDown className=\"ml-auto h-4 w-4 shrink-0 opacity-50\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-[9rem] p-0\" align=\"start\">\n          <Command>\n            <CommandList>\n              <CommandGroup>\n                {operators.map((operator) => (\n                  <CommandItem\n                    key={operator.value}\n                    onSelect={() => {\n                      onFilterChange({ ...filter, operator: operator.value })\n                      setOperatorOpen(false)\n                    }}\n                  >\n                    {operator.label}\n                  </CommandItem>\n                ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n\n      {renderValueInput()}\n\n      <Button variant=\"ghost\" size=\"icon\" onClick={onRemove}>\n        <X className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-filter-item.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-pagination.tsx",
      "content": "import { Table } from \"@tanstack/react-table\"\nimport {\n  ChevronLeft,\n  ChevronRight,\n  ChevronsLeft,\n  ChevronsRight,\n} from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\"\n\ninterface DataTablePaginationProps<TData> {\n  table: Table<TData>\n}\n\nexport function DataTablePagination<TData>({\n  table,\n}: DataTablePaginationProps<TData>) {\n  return (\n    <div className=\"flex items-center justify-between\">\n      {/* selected */}\n      <div className=\"text-muted-foreground flex-1 text-sm\">\n        <span className=\"hidden sm:inline\">\n          {table.getFilteredSelectedRowModel().rows.length} of{\" \"}\n          {table.getFilteredRowModel().rows.length} selected.\n        </span>\n        <span className=\"sm:hidden\">\n          {table.getFilteredSelectedRowModel().rows.length} selected\n        </span>\n      </div>\n\n      {/* rows per page */}\n      <div className=\"flex items-center justify-center space-x-2 flex-1\">\n        <p className=\"text-sm font-medium hidden sm:inline\">Rows per page</p>\n        <p className=\"text-sm font-medium sm:hidden\">Rows</p>\n        <Select\n          value={`${table.getState().pagination.pageSize}`}\n          onValueChange={(value) => {\n            table.setPageSize(Number(value))\n          }}\n        >\n          <SelectTrigger className=\"h-8 w-[70px]\">\n            <SelectValue placeholder={table.getState().pagination.pageSize} />\n          </SelectTrigger>\n          <SelectContent side=\"top\">\n            {[10, 20, 25, 30, 40, 50].map((pageSize) => (\n              <SelectItem key={pageSize} value={`${pageSize}`}>\n                {pageSize}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* pagination */}\n      <div className=\"flex items-center justify-end gap-4 flex-1\">\n                 <div className=\"flex w-[fit] items-center justify-center text-sm font-medium\">\n           <span className=\"hidden sm:inline\">\n             Page {table.getState().pagination.pageIndex + 1} of{\" \"}\n             {table.getPageCount()}\n           </span>\n           <span className=\"sm:hidden\">\n             Page {table.getState().pagination.pageIndex + 1}\n           </span>\n         </div>\n        <div className=\"flex items-center space-x-2\">\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"hidden size-8 lg:flex\"\n            onClick={() => table.setPageIndex(0)}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <span className=\"sr-only\">Go to first page</span>\n            <ChevronsLeft />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"size-8\"\n            onClick={() => table.previousPage()}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <span className=\"sr-only\">Go to previous page</span>\n            <ChevronLeft />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"size-8\"\n            onClick={() => table.nextPage()}\n            disabled={!table.getCanNextPage()}\n          >\n            <span className=\"sr-only\">Go to next page</span>\n            <ChevronRight />\n          </Button>\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"hidden size-8 lg:flex\"\n            onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n            disabled={!table.getCanNextPage()}\n          >\n            <span className=\"sr-only\">Go to last page</span>\n            <ChevronsRight />\n          </Button>\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-pagination.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-row-add.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { Plus } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle, SheetTrigger } from \"@/components/ui/sheet\"\nimport { DataTableRowForm } from \"./data-table-row-form\"\nimport { ColumnDef } from \"@tanstack/react-table\"\n\ninterface DataTableRowAddProps<TData> {\n  columns: ColumnDef<TData>[]\n  createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  customForm?: React.ComponentType<{\n    onSuccess?: () => void\n    onCancel?: () => void\n    createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n}\n\nexport default function DataTableRowAdd<TData>({ \n  columns, \n  createAction,\n  customForm: CustomForm \n}: DataTableRowAddProps<TData>) {\n  const [open, setOpen] = useState(false)\n\n  const handleSuccess = () => {\n    setOpen(false)\n    toast.success(\"Row added\", {\n      description: \"The new row has been successfully added.\",\n    })\n  }\n\n  const handleCancel = () => {\n    setOpen(false)\n  }\n\n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button variant=\"outline\" size=\"icon\">\n          <Plus className=\"size-4 shrink-0\" />\n        </Button>\n      </SheetTrigger>\n      <SheetContent className=\"flex flex-col sm:max-w-md\">\n        <SheetHeader>\n          <SheetTitle>Add New Row</SheetTitle>\n          <SheetDescription>Add a new row to the table.</SheetDescription>\n        </SheetHeader>\n        \n        <div className=\"flex-1 overflow-hidden\">\n          {CustomForm ? (\n            <CustomForm\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              createAction={createAction}\n            />\n          ) : (\n            <DataTableRowForm\n              columns={columns as ColumnDef<Record<string, unknown>>[]}\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              createAction={createAction as ((data: Partial<Record<string, unknown>>) => Promise<{ success: boolean; error?: string }>) | undefined}\n            />\n          )}\n        </div>\n      </SheetContent>\n    </Sheet>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-row-add.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-row-delete.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport { Trash2 } from \"lucide-react\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\"\n\ninterface DataTableRowDeleteProps {\n  selectedRowIds: string[]\n  deleteAction: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  onComplete?: () => void\n}\n\nexport default function DataTableRowDelete({ \n  selectedRowIds, \n  deleteAction,\n  onComplete \n}: DataTableRowDeleteProps) {\n  const router = useRouter()\n  const [isDeleting, setIsDeleting] = useState(false)\n  const [open, setOpen] = useState(false)\n\n  const handleDelete = async () => {\n    setIsDeleting(true)\n    \n    try {\n      const result = await deleteAction(selectedRowIds)\n      \n      if (result.success) {\n        toast.success(\"Rows deleted\", {\n          description: `${result.deletedCount || selectedRowIds.length} row(s) have been deleted.`,\n        })\n        router.refresh()\n        onComplete?.()\n        setOpen(false)\n      } else {\n        toast.error(\"Deletion failed\", {\n          description: result.error || \"An unknown error occurred.\",\n        })\n        console.error(\"Failed to delete items:\", result.error)\n      }\n    } catch (error) {\n      toast.error(\"Deletion failed\", {\n        description: \"An unexpected error occurred while deleting the items.\",\n      })\n      console.error(\"Error deleting items:\", error)\n    } finally {\n      setIsDeleting(false)\n    }\n  }\n\n  if (selectedRowIds.length === 0) {\n    return null\n  }\n\n  return (\n    <AlertDialog open={open} onOpenChange={setOpen}>\n      <AlertDialogTrigger asChild>\n        <Button variant=\"outline\">\n          <Trash2 className=\"size-4 shrink-0\" />\n          <Badge variant=\"secondary\">{selectedRowIds.length}</Badge>\n        </Button>\n      </AlertDialogTrigger>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>Delete Selected Items</AlertDialogTitle>\n          <AlertDialogDescription>\n            Are you sure you want to delete {selectedRowIds.length} selected item{selectedRowIds.length === 1 ? '' : 's'}? \n            This action cannot be undone.\n          </AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>\n          <AlertDialogAction\n            onClick={handleDelete}\n            disabled={isDeleting}\n            className=\"bg-destructive text-destructive-foreground hover:bg-destructive/90\"\n          >\n            {isDeleting ? \"Deleting...\" : \"Delete\"}\n          </AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-row-delete.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-row-edit-single.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { PencilRuler } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle, SheetTrigger } from \"@/components/ui/sheet\"\nimport { DataTableRowForm } from \"./data-table-row-form\"\nimport { ColumnDef } from \"@tanstack/react-table\"\n\ninterface DataTableRowEditSingleProps<TData> {\n  columns: ColumnDef<TData>[]\n  selectedRows: TData[]\n  updateActionSingle?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  customForm?: React.ComponentType<{\n    data: TData\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateAction?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n}\n\nexport default function DataTableRowEditSingle<TData>({ \n  columns, \n  selectedRows,\n  updateActionSingle,\n  customForm: CustomForm \n}: DataTableRowEditSingleProps<TData>) {\n  const [open, setOpen] = useState(false)\n\n  const handleSuccess = () => {\n    setOpen(false)\n    toast.success(\"Row updated\", {\n      description: \"The row has been successfully updated.\",\n    })\n  }\n\n  const handleCancel = () => {\n    setOpen(false)\n  }\n\n  // Only show edit button if exactly one row is selected\n  if (selectedRows.length !== 1) {\n    return null\n  }\n\n  const selectedRow = selectedRows[0]\n\n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button variant=\"outline\">\n          <PencilRuler className=\"size-4 shrink-0\" />\n          <Badge variant=\"secondary\">{selectedRows.length}</Badge>\n        </Button>\n      </SheetTrigger>\n      <SheetContent className=\"flex flex-col sm:max-w-md\">\n        <SheetHeader>\n          <SheetTitle>Edit Row</SheetTitle>\n          <SheetDescription>Edit the selected row.</SheetDescription>\n        </SheetHeader>\n        \n        <div className=\"flex-1 overflow-hidden\">\n          {CustomForm ? (\n            <CustomForm\n              data={selectedRow}\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              updateAction={updateActionSingle}\n            />\n          ) : (\n            <DataTableRowForm\n              columns={columns as ColumnDef<Record<string, unknown>>[]}\n              data={selectedRow as Record<string, unknown>}\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              updateAction={updateActionSingle as ((id: string, data: Partial<Record<string, unknown>>) => Promise<{ success: boolean; error?: string }>) | undefined}\n            />\n          )}\n        </div>\n      </SheetContent>\n    </Sheet>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-row-edit-single.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-row-edit-multi.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { PencilRuler } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { Button } from \"@/components/ui/button\"\nimport { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle, SheetTrigger } from \"@/components/ui/sheet\"\nimport { DataTableRowForm } from \"./data-table-row-form\"\nimport { ColumnDef } from \"@tanstack/react-table\"\nimport { Badge } from \"../ui/badge\"\n\ninterface DataTableRowEditMultiProps<TData> {\n  columns: ColumnDef<TData>[]\n  selectedRows: TData[]\n  selectedRowIds: string[]\n  updateActionMulti?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  customForm?: React.ComponentType<{\n    selectedCount: number\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateActionMulti?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  }>\n}\n\nexport default function DataTableRowEditMulti<TData>({ \n  columns, \n  selectedRows,\n  selectedRowIds,\n  updateActionMulti,\n  customForm: CustomForm \n}: DataTableRowEditMultiProps<TData>) {\n  const [open, setOpen] = useState(false)\n\n  const handleSuccess = () => {\n    setOpen(false)\n    toast.success(\"Rows updated\", {\n      description: `${selectedRows.length} row(s) have been successfully updated.`,\n    })\n  }\n\n  const handleCancel = () => {\n    setOpen(false)\n  }\n\n  // Only show multi edit button if more than one row is selected\n  if (selectedRows.length <= 1) {\n    return null\n  }\n\n  // Create a wrapper function that adapts the multi update action to work with the form\n  const adaptedUpdateAction = updateActionMulti ? async (id: string, data: Partial<TData>) => {\n    // For multi edit, we ignore the single id and use all selected ids\n    return await updateActionMulti(selectedRowIds, data)\n  } : undefined\n\n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button variant=\"outline\">\n          <PencilRuler className=\"size-4 shrink-0\" />\n          <Badge variant=\"secondary\">{selectedRows.length}</Badge>\n        </Button>\n      </SheetTrigger>\n      <SheetContent className=\"flex flex-col sm:max-w-md\">\n        <SheetHeader>\n          <SheetTitle>multi Edit Rows</SheetTitle>\n          <SheetDescription>\n            Edit {selectedRows.length} selected row(s). Only fields you modify will be updated.\n          </SheetDescription>\n        </SheetHeader>\n        \n        <div className=\"flex-1 overflow-hidden\">\n          {CustomForm ? (\n            <CustomForm\n              selectedCount={selectedRows.length}\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              updateActionMulti={updateActionMulti ? async (ids: string[], data: Partial<TData>) => {\n                // Use the selectedRowIds from this component instead of the empty array passed from the form\n                return await updateActionMulti(selectedRowIds, data)\n              } : undefined}\n            />\n          ) : (\n            <DataTableRowForm\n              columns={columns as ColumnDef<Record<string, unknown>>[]}\n              data={{}} // Empty data for multi edit - only show fields to modify\n              onSuccess={handleSuccess}\n              onCancel={handleCancel}\n              updateAction={adaptedUpdateAction as ((id: string, data: Partial<Record<string, unknown>>) => Promise<{ success: boolean; error?: string }>) | undefined}\n              isMultiEdit={true}\n            />\n          )}\n        </div>\n      </SheetContent>\n    </Sheet>\n  )\n} ",
      "type": "registry:component",
      "target": "components/data-table/data-table-row-edit-multi.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-row-form.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport { ColumnDef } from \"@tanstack/react-table\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Label } from \"@/components/ui/label\"\nimport { Textarea } from \"@/components/ui/textarea\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\"\nimport { Switch } from \"@/components/ui/switch\"\nimport { Calendar } from \"@/components/ui/calendar\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { cn } from \"@/lib/utils\"\nimport { format } from \"date-fns\"\nimport { CalendarIcon, X, Plus, Save } from \"lucide-react\"\n\ninterface DataTableRowFormProps<TData> {\n  columns: ColumnDef<TData>[]\n  data?: TData\n  onSuccess?: () => void\n  onCancel?: () => void\n  createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateAction?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  isMultiEdit?: boolean\n}\n\ntype FormData = Record<string, string | boolean | string[] | null | undefined>\n\ntype ColumnMeta = {\n  label: string\n  variant?: \"text\" | \"select\" | \"multiSelect\" | \"boolean\" | \"date\" | \"number\" | \"range\" | \"dateRange\"\n  placeholder?: string\n  options?: { label: string; value: string }[]\n  rows?: number\n  excludeFromForm?: boolean\n  readOnly?: boolean\n}\n\ntype FormColumn<TData> = ColumnDef<TData> & {\n  accessorKey?: string\n  meta?: ColumnMeta\n}\n\nexport function DataTableRowForm<TData extends Record<string, unknown>>({ \n  columns, \n  data, \n  onSuccess, \n  onCancel,\n  createAction,\n  updateAction,\n  isMultiEdit = false\n}: DataTableRowFormProps<TData>) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const isEditing = !!data\n  \n  // Use only the passed columns for form generation\n  const formColumns = columns as FormColumn<TData>[]\n  \n  const [formData, setFormData] = useState<FormData>(() => {\n    const initialData: FormData = {}\n    \n    // Initialize form data based on columns, excluding those marked to exclude from form\n    formColumns.forEach(column => {\n      if ('accessorKey' in column && column.accessorKey && !column.meta?.excludeFromForm) {\n        const key = column.accessorKey as string\n        // For multi edit, start with empty values so only modified fields are updated\n        initialData[key] = isMultiEdit ? \"\" : (data?.[key as keyof TData] as string | boolean | string[] | null | undefined) ?? \"\"\n      }\n    })\n    \n    return initialData\n  })\n\n  const handleInputChange = (field: string, value: string | boolean | string[] | null | undefined) => {\n    setFormData(prev => ({ ...prev, [field]: value }))\n  }\n\n  const renderFormField = (column: FormColumn<TData>) => {\n    if (!('accessorKey' in column) || !column.accessorKey) return null\n    \n    const fieldName = column.accessorKey as string\n    \n    // Check if this field should be excluded from the form\n    if (column.meta?.excludeFromForm) return null\n    \n    // Hide readonly fields in add form\n    if (!isEditing && column.meta?.readOnly) return null\n    \n    const value = formData[fieldName]\n    const meta = column.meta\n    if (!meta) return null\n    \n    const { label, variant, placeholder, options, rows, readOnly } = meta\n    \n    switch (variant) {\n      case \"multiSelect\":\n        const selectedValues = Array.isArray(value) ? value : []\n        \n        return (\n          <div key={fieldName} className=\"space-y-2\">\n            <Label className={cn(readOnly && \"text-muted-foreground\")}>{label}</Label>\n            <div className=\"flex flex-wrap gap-2\">\n              {options?.map((option: { label: string; value: string }) => (\n                <Button\n                  key={option.value}\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  disabled={readOnly}\n                  className=\"h-auto p-0 hover:bg-transparent\"\n                  onClick={readOnly ? undefined : () => {\n                    const newValues = selectedValues.includes(option.value)\n                      ? selectedValues.filter((v: string) => v !== option.value)\n                      : [...selectedValues, option.value]\n                    handleInputChange(fieldName, newValues)\n                  }}\n                >\n                  <Badge\n                    variant={selectedValues.includes(option.value) ? \"default\" : \"outline\"}\n                    className={readOnly ? \"cursor-default\" : \"cursor-pointer\"}\n                  >\n                    {option.label}\n                  </Badge>\n                </Button>\n              ))}\n            </div>\n          </div>\n        )\n        \n      case \"select\":\n        return (\n          <div key={fieldName} className=\"space-y-2\">\n            <Label htmlFor={fieldName} className={cn(readOnly && \"text-muted-foreground\")}>{label}</Label>\n            <Select \n              value={value as string || \"\"} \n              onValueChange={(newValue) => handleInputChange(fieldName, newValue)}\n              disabled={readOnly}\n            >\n              <SelectTrigger>\n                <SelectValue placeholder={placeholder || `Select ${label?.toLowerCase()}...`} />\n              </SelectTrigger>\n              <SelectContent>\n                {options?.map((option: { label: string; value: string }) => (\n                  <SelectItem key={option.value} value={option.value}>\n                    {option.label}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n        )\n        \n      case \"boolean\":\n        return (\n          <div key={fieldName} className=\"flex items-center justify-between rounded-lg border p-3\">\n            <Label htmlFor={fieldName} className={cn(\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\", readOnly && \"text-muted-foreground\")}>\n              {label}\n            </Label>\n            <Switch\n              id={fieldName}\n              checked={!!value}\n              onCheckedChange={(checked) => handleInputChange(fieldName, checked)}\n              disabled={readOnly}\n            />\n          </div>\n        )\n        \n      case \"date\":\n        const dateValue = value ? new Date(value as string) : undefined\n        \n        return (\n          <div key={fieldName} className=\"space-y-2\">\n            <Label htmlFor={fieldName} className={cn(readOnly && \"text-muted-foreground\")}>{label}</Label>\n            <Popover>\n              <PopoverTrigger asChild>\n                <Button\n                  variant=\"outline\"\n                  disabled={readOnly}\n                  className={cn(\n                    \"w-full justify-start text-left font-normal\",\n                    !value && \"text-muted-foreground\"\n                  )}\n                >\n                  <CalendarIcon className=\"mr-2 h-4 w-4\" />\n                  {value ? format(dateValue!, \"PPP\") : <span>{placeholder || \"Pick a date\"}</span>}\n                </Button>\n              </PopoverTrigger>\n              {!readOnly && (\n                <PopoverContent className=\"w-auto p-0\">\n                  <Calendar\n                    mode=\"single\"\n                    selected={dateValue}\n                    onSelect={(date) => handleInputChange(fieldName, date ? format(date, \"yyyy-MM-dd\") : \"\")}\n                  />\n                </PopoverContent>\n              )}\n            </Popover>\n          </div>\n        )\n        \n      case \"text\":\n      default:\n        // Special handling for notes field as textarea\n        if (fieldName === \"notes\") {\n          return (\n            <div key={fieldName} className=\"space-y-2\">\n              <Label htmlFor={fieldName} className={cn(readOnly && \"text-muted-foreground\")}>{label}</Label>\n              <Textarea\n                id={fieldName}\n                value={value as string || \"\"}\n                onChange={(e) => handleInputChange(fieldName, e.target.value)}\n                placeholder={placeholder}\n                rows={rows || 3}\n                disabled={readOnly}\n              />\n            </div>\n          )\n        }\n        \n        // Determine input type based on field name patterns\n        let inputType = \"text\"\n        if (fieldName.includes(\"email\")) inputType = \"email\"\n        else if (fieldName.includes(\"phone\") || fieldName.includes(\"tel\")) inputType = \"tel\"\n        else if (fieldName.includes(\"url\") || fieldName.includes(\"website\")) inputType = \"url\"\n        else if (fieldName.includes(\"number\") || fieldName.includes(\"amount\") || fieldName.includes(\"quantity\")) inputType = \"number\"\n        \n        return (\n          <div key={fieldName} className=\"space-y-2\">\n            <Label htmlFor={fieldName} className={cn(readOnly && \"text-muted-foreground\")}>{label}</Label>\n            <Input\n              id={fieldName}\n              type={inputType}\n              value={value as string || \"\"}\n              onChange={(e) => handleInputChange(fieldName, e.target.value)}\n              placeholder={placeholder}\n              disabled={readOnly}\n            />\n          </div>\n        )\n    }\n  }\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setIsSubmitting(true)\n    \n    try {\n      // Clean up the data and filter out read-only fields\n      const cleanedData: Record<string, string | boolean | string[] | null | undefined> = {}\n      \n      Object.entries(formData).forEach(([key, value]) => {\n        // Check if this field is read-only\n        const column = formColumns.find(col => 'accessorKey' in col && col.accessorKey === key)\n        if (column?.meta?.readOnly) return // Skip read-only fields\n        \n        // For multi edit, only include fields that have been modified (not empty)\n        if (isMultiEdit) {\n          if (typeof value === 'string' && value.trim() === '') return\n          if (Array.isArray(value) && value.length === 0) return\n          if (value === null || value === undefined) return\n        }\n        \n        if (typeof value === 'string') {\n          cleanedData[key] = value.trim() || undefined\n        } else if (Array.isArray(value)) {\n          cleanedData[key] = value.length > 0 ? value : null\n        } else {\n          cleanedData[key] = value\n        }\n      })\n\n      let result\n      if (isMultiEdit && updateAction) {\n        // For multi edit, use updateAction with empty id (the action will handle multiple IDs)\n        const updateData = Object.fromEntries(\n          Object.entries(cleanedData).filter(([, v]) => v !== undefined)\n        )\n        result = await updateAction('', updateData as Partial<TData>)\n      } else if (isEditing && updateAction && data && 'id' in data) {\n        const updateData = Object.fromEntries(\n          Object.entries(cleanedData).filter(([, v]) => v !== undefined)\n        )\n        result = await updateAction(data.id as string, updateData as Partial<TData>)\n      } else if (!isEditing && createAction) {\n        result = await createAction(cleanedData as Partial<TData>)\n      } else {\n        console.error(\"Missing action or data for form submission\")\n        return\n      }\n      \n      if (result.success) {\n        router.refresh()\n        onSuccess?.()\n      } else {\n        console.error(`Failed to ${isEditing ? 'update' : 'create'} record:`, result.error)\n      }\n    } catch (error) {\n      console.error(\"Error submitting form:\", error)\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  // Group columns by common patterns for better layout\n  const groupFields = (cols: FormColumn<TData>[]) => {\n    const groups: Record<string, FormColumn<TData>[]> = {\n      name: [],\n      contact: [],\n      work: [],\n      other: [],\n      readonly: []\n    }\n    \n    cols.forEach(col => {\n      if (!('accessorKey' in col) || !col.accessorKey || col.meta?.excludeFromForm) return\n      \n      // Skip readonly fields in add form\n      if (!isEditing && col.meta?.readOnly) return\n      \n      const key = col.accessorKey as string\n      \n      // Group readonly fields separately\n      if (col.meta?.readOnly) {\n        groups.readonly.push(col)\n      } else if (key.includes('name')) {\n        groups.name.push(col)\n      } else if (key.includes('email') || key.includes('phone')) {\n        groups.contact.push(col)\n      } else if (key.includes('company') || key.includes('job') || key.includes('title')) {\n        groups.work.push(col)\n      } else {\n        groups.other.push(col)\n      }\n    })\n    \n    return groups\n  }\n  \n  const fieldGroups = groupFields(formColumns)\n\n  return (\n    <form onSubmit={handleSubmit} className=\"h-full flex flex-col\">\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-6\">\n        {/* Name fields */}\n        {fieldGroups.name.length > 0 && (\n          <div className={fieldGroups.name.length > 1 ? \"grid grid-cols-2 gap-4\" : \"\"}>\n            {fieldGroups.name.map(renderFormField)}\n          </div>\n        )}\n        \n        {/* Contact fields */}\n        {fieldGroups.contact.length > 0 && (\n          <div className={fieldGroups.contact.length > 1 ? \"grid grid-cols-2 gap-4\" : \"\"}>\n            {fieldGroups.contact.map(renderFormField)}\n          </div>\n        )}\n        \n        {/* Work fields */}\n        {fieldGroups.work.length > 0 && (\n          <div className={fieldGroups.work.length > 1 ? \"grid grid-cols-2 gap-4\" : \"\"}>\n            {fieldGroups.work.map(renderFormField)}\n          </div>\n        )}\n        \n        {/* Other fields */}\n        {fieldGroups.other.map(renderFormField)}\n        \n        {/* Readonly fields - only show in edit mode */}\n        {isEditing && fieldGroups.readonly.length > 0 && (\n          <>\n            <div className=\"py-2\">\n              <Separator />\n            </div>\n            <div className=\"space-y-4\">\n              {fieldGroups.readonly.map(renderFormField)}\n            </div>\n          </>\n        )}\n      </div>\n\n      <div className=\"flex justify-between gap-2 p-4 border-t bg-background\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={onCancel}\n          className=\"w-1/2\"\n        >\n          <X className=\"size-4 shrink-0\" /> Cancel\n        </Button>\n        <Button\n          type=\"submit\"\n          disabled={isSubmitting}\n          className=\"w-1/2\"\n        >\n          {isMultiEdit ? (\n            <>\n              <Save className=\"size-4 shrink-0\" />\n              {isSubmitting ? \"Updating...\" : \"Update All\"}\n            </>\n          ) : isEditing ? (\n            <>\n              <Save className=\"size-4 shrink-0\" />\n              {isSubmitting ? \"Saving...\" : \"Save Changes\"}\n            </>\n          ) : (\n            <>\n              <Plus className=\"size-4 shrink-0\" />\n              {isSubmitting ? \"Adding...\" : \"Add Record\"}\n            </>\n          )}\n        </Button>\n      </div>\n    </form>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-row-form.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-sort.tsx",
      "content": "import { ChevronRight, ChevronsUpDown, Plus } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\nimport { useState, useEffect } from \"react\";\nimport DataTableSortItem from \"./data-table-sort-item\";\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  DragEndEvent,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { SortingState, Table } from \"@tanstack/react-table\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Badge } from \"@/components/ui/badge\";\n\ninterface SortItem {\n  id: string;\n  column?: string;\n  direction: \"asc\" | \"desc\";\n}\n\ninterface DataTableSortProps<TData> {\n  table: Table<TData>;\n}\n\nexport default function DataTableSort<TData>({ table }: DataTableSortProps<TData>) {\n  const [sortItems, setSortItems] = useState<SortItem[]>([]);\n  const [open, setOpen] = useState(false);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Sync sortItems with table's sorting state\n  useEffect(() => {\n    const currentSorting = table.getState().sorting;\n    if (currentSorting.length > 0) {\n      const newSortItems: SortItem[] = currentSorting.map((sort, index) => ({\n        id: `${sort.id}-${index}`, // Create unique ID\n        column: sort.id,\n        direction: sort.desc ? \"desc\" : \"asc\",\n      }));\n      setSortItems(newSortItems);\n    } else {\n      // If no sorting is applied, show one empty sort item\n      setSortItems([{ id: \"1\", direction: \"asc\" }]);\n    }\n  }, [table.getState().sorting]);\n\n  const addSortItem = () => {\n    const newId = Date.now().toString(); // Use timestamp for unique IDs\n    setSortItems([...sortItems, { id: newId, direction: \"asc\" }]);\n  };\n\n  const removeSortItem = (id: string) => {\n    setSortItems(sortItems.filter(item => item.id !== id));\n  };\n\n  const updateSortItemColumn = (id: string, column: string) => {\n    setSortItems(sortItems.map(item => \n      item.id === id ? { ...item, column } : item\n    ));\n  };\n\n  const updateSortItemDirection = (id: string, direction: \"asc\" | \"desc\") => {\n    setSortItems(sortItems.map(item => \n      item.id === id ? { ...item, direction } : item\n    ));\n  };\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n\n    if (over && active.id !== over.id) {\n      setSortItems((items) => {\n        const oldIndex = items.findIndex((item) => item.id === active.id);\n        const newIndex = items.findIndex((item) => item.id === over.id);\n\n        return arrayMove(items, oldIndex, newIndex);\n      });\n    }\n  };\n\n  const applySort = () => {\n    const sorting: SortingState = sortItems\n      .filter((item) => !!item.column)\n      .map((item) => ({\n        id: item.column!,\n        desc: item.direction === \"desc\",\n      }));\n    table.setSorting(sorting);\n    setOpen(false); // Close the popover after applying sort\n  };\n\n  const columns = table\n    .getAllColumns()\n    .filter(\n      (column) =>\n        typeof column.accessorFn !== \"undefined\" && column.getCanSort()\n    );\n\n  // Get the actual number of applied sorts from the table state\n  const appliedSortCount = table.getState().sorting.length;\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button variant=\"outline\">\n          <ChevronsUpDown className=\"w-4 h-4\" />\n          <div>Sort</div>\n          <Badge variant=\"secondary\">\n            {appliedSortCount}\n          </Badge>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"start\" className=\"w-sm p-3\">\n        <div className=\"flex flex-col gap-3 w-full\">\n          <p className=\"text-sm font-medium text-muted-foreground\">\n            Sort by:\n          </p>\n          \n          <DndContext\n            sensors={sensors}\n            collisionDetection={closestCenter}\n            onDragEnd={handleDragEnd}\n          >\n            <SortableContext items={sortItems.map(item => item.id)} strategy={verticalListSortingStrategy}>\n              {sortItems.map((item) => (\n                <DataTableSortItem\n                  key={item.id}\n                  id={item.id}\n                  column={item.column}\n                  direction={item.direction}\n                  onColumnChange={updateSortItemColumn}\n                  onDirectionChange={updateSortItemDirection}\n                  onRemove={removeSortItem}\n                  columns={columns}\n                />\n              ))}\n            </SortableContext>\n          </DndContext>\n\n          <Separator />\n\n          <div className=\"flex flex-row gap-3 items-center justify-between\">\n            <Button variant=\"secondary\" onClick={addSortItem} className=\"flex flex-row items-center h-8\">\n              <Plus className=\"w-4 h-4\" />\n              Add\n            </Button>\n            <Button variant=\"default\" onClick={applySort} className=\"flex flex-row items-center h-8\">\n              Apply\n              <ChevronRight className=\"w-4 h-4\" />\n            </Button>\n          </div>\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-sort.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-sort-item.tsx",
      "content": "import { ChevronsUpDown, GripVertical, X } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from \"@/components/ui/command\";\nimport { useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { Column } from \"@tanstack/react-table\";\nimport { useState } from \"react\";\n\ninterface DataTableSortItemProps<TData> {\n  id: string;\n  column?: string;\n  direction: \"asc\" | \"desc\";\n  onColumnChange: (id: string, column: string) => void;\n  onDirectionChange: (id: string, direction: \"asc\" | \"desc\") => void;\n  onRemove: (id: string) => void;\n  columns: Column<TData, unknown>[];\n}\n\nexport default function DataTableSortItem<TData>({\n  id,\n  column,\n  direction,\n  onColumnChange,\n  onDirectionChange,\n  onRemove,\n  columns,\n}: DataTableSortItemProps<TData>) {\n  const [open, setOpen] = useState(false);\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id });\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n  };\n\n  return (\n    <div \n      ref={setNodeRef} \n      style={style}\n      className=\"flex flex-row gap-2 items-center w-full\"\n    >\n      <Button \n        variant=\"ghost\" \n        size=\"icon\"\n        {...attributes}\n        {...listeners}\n        className=\"cursor-grab active:cursor-grabbing\"\n      >\n        <GripVertical className=\"w-4 h-4\" />\n      </Button>\n\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <Button variant=\"outline\" className=\"flex-1\">\n            <span className=\"flex-1 text-left capitalize\">\n              {column ? \n                (columns.find(col => col.id === column)?.columnDef.meta?.label ?? column) \n                : \"Column\"\n              }\n            </span>\n            <ChevronsUpDown className=\"w-4 h-4\" />\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent align=\"start\" className=\"p-0\">\n          <Command>\n            <CommandInput placeholder=\"Search column\" />\n            <CommandList>\n              <CommandEmpty>No results found.</CommandEmpty>\n              <CommandGroup>\n                {columns.map((col) => (\n                  <CommandItem\n                    key={col.id}\n                    onSelect={() => {\n                      onColumnChange(id, col.id);\n                      setOpen(false);\n                    }}\n                    className=\"capitalize\"\n                  >\n                    {col.columnDef.meta?.label ?? col.id}\n                  </CommandItem>\n                ))}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n\n      <Select value={direction} onValueChange={(value: \"asc\" | \"desc\") => onDirectionChange(id, value)}>\n        <SelectTrigger className=\"w-[5.25rem]\">\n          <SelectValue placeholder=\"Sort\" />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"asc\">Asc</SelectItem>\n          <SelectItem value=\"desc\">Desc</SelectItem>\n        </SelectContent>\n      </Select>\n\n      <Button variant=\"ghost\" size=\"icon\" onClick={() => onRemove(id)}>\n        <X className=\"w-4 h-4\" />\n      </Button>\n    </div>\n  );\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-sort-item.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-toolbar.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { Table } from \"@tanstack/react-table\"\nimport { Settings2, X } from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\n\nimport DataTableFilter from \"./data-table-filter\"\nimport DataTableSort from \"./data-table-sort\"\nimport DataTableRowAdd from \"./data-table-row-add\"\nimport DataTableRowEditSingle from \"./data-table-row-edit-single\"\nimport DataTableRowEditMulti from \"./data-table-row-edit-multi\"\nimport DataTableRowDelete from \"./data-table-row-delete\"\n\ninterface DataTableToolbarProps<TData> {\n  table: Table<TData>\n  deleteAction?: (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateActionSingle?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  updateActionMulti?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  customAddForm?: React.ComponentType<{\n    onSuccess?: () => void\n    onCancel?: () => void\n    createAction?: (data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n  customEditFormSingle?: React.ComponentType<{\n    data: TData\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateAction?: (id: string, data: Partial<TData>) => Promise<{ success: boolean; error?: string }>\n  }>\n  customEditFormMulti?: React.ComponentType<{\n    selectedCount: number\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateActionMulti?: (ids: string[], data: Partial<TData>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  }>\n}\n\nexport default function DataTableToolbar<TData>({\n  table,\n  deleteAction,\n  createAction,\n  updateActionSingle,\n  updateActionMulti,\n  customAddForm,\n  customEditFormSingle,\n  customEditFormMulti,\n}: DataTableToolbarProps<TData>) {\n  // Get selected rows data\n  const selectedRows = table.getFilteredSelectedRowModel().rows.map(row => row.original)\n  const selectedRowIds = table.getFilteredSelectedRowModel().rows.map(row => {\n    const rowData = row.original as Record<string, unknown>\n    return String(rowData.id || '')\n  }).filter(Boolean)\n\n  const handleDeleteComplete = () => {\n    table.resetRowSelection()\n  }\n\n  const isFiltered = table.getState().columnFilters.length > 0\n  const isSorted = table.getState().sorting.length > 0\n\n  return (\n    <div className=\"flex items-center gap-2\">\n\n      {/* Action Buttons */}\n      {createAction && (\n        <DataTableRowAdd \n          columns={table.getAllColumns().map(col => col.columnDef)} \n          createAction={createAction}\n          customForm={customAddForm}\n        />\n      )}\n      {updateActionSingle && (\n        <DataTableRowEditSingle \n          columns={table.getAllColumns().map(col => col.columnDef)} \n          selectedRows={selectedRows} \n          updateActionSingle={updateActionSingle}\n          customForm={customEditFormSingle}\n        />\n      )}\n      {updateActionMulti && (\n        <DataTableRowEditMulti \n          columns={table.getAllColumns().map(col => col.columnDef)} \n          selectedRows={selectedRows} \n          selectedRowIds={selectedRowIds}\n          updateActionMulti={updateActionMulti}\n          customForm={customEditFormMulti}\n        />\n      )}\n      {deleteAction && selectedRowIds.length > 0 && (\n        <DataTableRowDelete \n          selectedRowIds={selectedRowIds} \n          deleteAction={deleteAction}\n          onComplete={handleDeleteComplete}\n        />\n      )}    \n\n      {/* Sort Controls */}\n      <DataTableSort table={table} />\n\n      {/* Column Filters */}\n      <DataTableFilter table={table} />\n\n      {/* Clear filters and Sort */}\n      {(isFiltered || isSorted) && (\n        <Button\n          variant=\"secondary\"\n          onClick={() => {\n            table.resetColumnFilters(true)\n            table.resetSorting(true)\n          }}\n        >\n          Reset\n          <X className=\"h-4 w-4\" />\n        </Button>\n      )}\n\n      <div className=\"ml-auto flex items-center gap-2\">\n        {/* Column visibility toggle */}\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button variant=\"outline\" size=\"icon\">\n              <Settings2 className=\"h-4 w-4\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"end\" className=\"w-[200px]\">\n            <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>\n            <DropdownMenuSeparator />\n            {table\n              .getAllColumns()\n              .filter(\n                (column) =>\n                  typeof column.accessorFn !== \"undefined\" && column.getCanHide()\n              )\n              .map((column) => {\n                return (\n                  <DropdownMenuCheckboxItem\n                    key={column.id}\n                    className=\"capitalize\"\n                    checked={column.getIsVisible()}\n                    onCheckedChange={(value) => column.toggleVisibility(!!value)}\n                  >\n                    {column.id}\n                  </DropdownMenuCheckboxItem>\n                )\n              })}\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </div>\n    </div>\n  )\n}",
      "type": "registry:component",
      "target": "components/data-table/data-table-toolbar.tsx"
    },
    {
      "path": "registry/data-table/components/data-table/data-table-view-options.tsx",
      "content": "\"use client\"\n\nimport {\n  DndContext,\n  closestCenter,\n  type DragEndEvent,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\"\nimport {\n  SortableContext,\n  arrayMove,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\nimport { type Column, Table } from \"@tanstack/react-table\"\nimport { GripVertical, Settings2 } from \"lucide-react\"\nimport * as React from \"react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\n\ninterface SortableColumnProps<TData> {\n  column: Column<TData, unknown>\n}\n\nfunction SortableColumn<TData>({ column }: SortableColumnProps<TData>) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id: column.id })\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n    zIndex: isDragging ? 1 : 0,\n    position: \"relative\" as const,\n  }\n\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className=\"flex w-full items-center justify-between\"\n    >\n      <DropdownMenuCheckboxItem\n        className=\"w-full capitalize\"\n        checked={column.getIsVisible() ?? true}\n        onCheckedChange={(value) => column.toggleVisibility(!!value)}\n        onSelect={(event) => event.preventDefault()}\n      >\n        {column.columnDef.meta?.label ?? column.id}\n      </DropdownMenuCheckboxItem>\n      <Button\n        variant=\"ghost\"\n        size=\"sm\"\n        className=\"cursor-grab hover:cursor-grabbing\"\n        {...attributes}\n        {...listeners}\n      >\n        <GripVertical className=\"size-4\" />\n      </Button>\n    </div>\n  )\n}\n\nexport function DataTableViewOptions<TData>({\n  table,\n}: {\n  table: Table<TData>\n}) {\n  const { columnOrder } = table.getState()\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  )\n\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event\n    if (over && active.id !== over.id) {\n      const oldIndex = columnOrder.indexOf(active.id as string)\n      const newIndex = columnOrder.indexOf(over.id as string)\n      table.setColumnOrder(arrayMove(columnOrder, oldIndex, newIndex))\n    }\n  }\n\n  // Get all columns for ordering (including non-hideable ones)\n  const allColumns = table.getAllColumns()\n  \n  // Get only hideable columns for the view options display\n  const hideableColumns = React.useMemo(() => {\n    const columns =\n      columnOrder.length > 0\n        ? columnOrder\n            .map((id) => table.getColumn(id))\n            .filter(\n              (col): col is Column<TData, unknown> => {\n                if (!col || typeof col.accessorFn === \"undefined\") return false\n                const canHide = col.getCanHide()\n                return canHide === true\n              }\n            )\n        : table\n            .getAllColumns()\n            .filter(\n              (column) => {\n                if (typeof column.accessorFn === \"undefined\") return false\n                const canHide = column.getCanHide()\n                return canHide === true\n              }\n            )\n    return columns\n  }, [columnOrder, table])\n\n  // Initialize column order with all columns if not set\n  React.useEffect(() => {\n    if (columnOrder.length === 0 && allColumns.length > 0) {\n      table.setColumnOrder(allColumns.map((c) => c.id))\n    }\n  }, [columnOrder.length, allColumns, table])\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\" size=\"sm\" className=\"ml-auto\">\n          <Settings2 />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\" className=\"\">\n        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>\n        <DropdownMenuSeparator />\n        <DndContext\n          sensors={sensors}\n          collisionDetection={closestCenter}\n          onDragEnd={handleDragEnd}\n        >\n          <SortableContext\n            items={hideableColumns.map((c) => c.id)}\n            strategy={verticalListSortingStrategy}\n          >\n            {hideableColumns.map((column) => (\n              <SortableColumn key={column.id} column={column} />\n            ))}\n          </SortableContext>\n        </DndContext>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-view-options.tsx"
    },
    {
      "path": "registry/data-table/components/ui/badge.tsx",
      "content": "import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\n        destructive:\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\n        gray: \n          \"border-transparent bg-gray-50 text-gray-600 dark:text-gray-400 dark:bg-gray-900/20 ring-1 ring-inset ring-gray-500/10 dark:ring-gray-600/50\",\n        red: \n          \"border-transparent bg-red-50 text-red-700 dark:text-red-400 dark:bg-red-900/20 ring-1 ring-inset ring-red-600/10 dark:ring-red-600/30\",\n        yellow: \n          \"border-transparent bg-yellow-50 text-yellow-800 dark:text-yellow-400 dark:bg-yellow-900/20 ring-1 ring-inset ring-yellow-600/20 dark:ring-yellow-600/30\",\n        orange:\n          \"border-transparent bg-orange-50 text-orange-800 dark:text-orange-400 dark:bg-orange-900/20 ring-1 ring-inset ring-orange-600/20 dark:ring-orange-600/30\",\n        amber:\n          \"border-transparent bg-amber-50 text-amber-800 dark:text-amber-400 dark:bg-amber-900/20 ring-1 ring-inset ring-amber-600/20 dark:ring-amber-600/30\",\n        green: \n          \"border-transparent bg-green-50 text-green-700 dark:text-green-400 dark:bg-green-900/20 ring-1 ring-inset ring-green-600/20 dark:ring-green-600/30\",\n        blue: \n          \"border-transparent bg-blue-50 text-blue-700 dark:text-blue-400 dark:bg-blue-900/20 ring-1 ring-inset ring-blue-700/10 dark:ring-blue-600/30\",\n        indigo: \n          \"border-transparent bg-indigo-50 text-indigo-700 dark:text-indigo-400 dark:bg-indigo-900/20 ring-1 ring-inset ring-indigo-700/10 dark:ring-indigo-600/30\",\n        purple: \n          \"border-transparent bg-purple-50 text-purple-700 dark:text-purple-400 dark:bg-purple-900/20 ring-1 ring-inset ring-purple-700/10 dark:ring-purple-600/30\",\n        pink: \n          \"border-transparent bg-pink-50 text-pink-700 dark:text-pink-400 dark:bg-pink-900/20 ring-1 ring-inset ring-pink-700/10 dark:ring-pink-600/30\",\n        },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps extends VariantProps<typeof badgeVariants> {\n  /**\n   * The content to display inside the badge\n   */\n  children?: React.ReactNode;\n  /**\n   * Additional CSS classes to apply to the badge\n   */\n  className?: string;\n}\n\nfunction Badge({\n  variant,\n  children,\n  className,\n}: BadgeProps) {\n  return (\n    <span\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n    >\n      {children}\n    </span>\n  )\n}\n\nexport { Badge, badgeVariants }\n",
      "type": "registry:component",
      "target": "components/ui/badge.tsx"
    },
    {
      "path": "registry/data-table/components/ui/input-number.tsx",
      "content": "\"use client\"\n\nimport { ChevronDownIcon, ChevronUpIcon } from \"lucide-react\"\nimport { Button, Group, Input, NumberField as AriaNumberField } from \"react-aria-components\"\nimport { cn } from \"@/lib/utils\"\n\ninterface InputNumberProps {\n  value?: number | string\n  onChange?: (value: number) => void\n  placeholder?: string\n  className?: string\n  unit?: string\n}\n\nexport function InputNumber({ value, onChange, placeholder, className, unit }: InputNumberProps) {\n  return (\n    <AriaNumberField\n      value={typeof value === 'string' ? (value === '' ? undefined : Number(value)) : value}\n      onChange={onChange}\n      className={className}\n    >\n      <Group className=\"border-input outline-none data-focus-within:border-ring data-focus-within:ring-ring/50 data-focus-within:has-aria-invalid:ring-destructive/20 dark:data-focus-within:has-aria-invalid:ring-destructive/40 data-focus-within:has-aria-invalid:border-destructive relative inline-flex h-9 w-full items-center overflow-hidden rounded-md border text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] data-disabled:opacity-50 data-focus-within:ring-[3px] bg-transparent dark:bg-input/30\">\n        <div className=\"relative flex-1\">\n          {unit && (\n            <div className=\"absolute left-3 top-1/2 -translate-y-1/2 text-sm text-muted-foreground z-10\">\n              {unit}\n            </div>\n          )}\n          <Input \n            placeholder={placeholder}\n            className={cn(\n              \"text-foreground flex-1 px-3 py-2 tabular-nums border-0 outline-none w-full bg-transparent placeholder:text-muted-foreground\",\n              unit && \"pl-8\"\n            )} \n          />\n        </div>\n        <div className=\"flex h-[calc(100%+2px)] flex-col\">\n          <Button\n            slot=\"increment\"\n            className=\"border-input text-muted-foreground/80 hover:bg-accent hover:text-foreground -me-px flex h-1/2 w-6 flex-1 items-center justify-center border text-sm transition-[color,box-shadow] disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\"\n          >\n            <ChevronUpIcon size={12} aria-hidden=\"true\" />\n          </Button>\n          <Button\n            slot=\"decrement\"\n            className=\"border-input text-muted-foreground/80 hover:bg-accent hover:text-foreground -me-px -mt-px flex h-1/2 w-6 flex-1 items-center justify-center border text-sm transition-[color,box-shadow] disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\"\n          >\n            <ChevronDownIcon size={12} aria-hidden=\"true\" />\n          </Button>\n        </div>\n      </Group>\n    </AriaNumberField>\n  )\n} ",
      "type": "registry:component",
      "target": "components/ui/input-number.tsx"
    },
    {
      "path": "registry/data-table/lib/data-table.ts",
      "content": "import type { RowData } from \"@tanstack/react-table\";\nimport type { ColumnFiltersState, PaginationState, SortingState, VisibilityState, ColumnOrderState } from \"@tanstack/react-table\";\n\nexport type DataTableConfig = typeof dataTableConfig;\n\nexport const dataTableConfig = {\n  textOperators: [\n    { label: \"Contains\", value: \"iLike\" as const },\n    { label: \"Does not contain\", value: \"notILike\" as const },\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  numericOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is less than\", value: \"lt\" as const },\n    { label: \"Is greater than\", value: \"gt\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  dateOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is before\", value: \"lt\" as const },\n    { label: \"Is after\", value: \"gt\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  selectOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  multiSelectOperators: [\n    { label: \"Has any of\", value: \"inArray\" as const },\n    { label: \"Has none of\", value: \"notInArray\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  booleanOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n  ],\n  filterVariants: [\n    \"text\", \"number\", \"range\", \"date\", \"dateRange\", \"boolean\", \"select\", \"multiSelect\"\n  ] as const,\n  operators: [\n    \"iLike\", \"notILike\", \"eq\", \"ne\", \"inArray\", \"notInArray\", \n    \"isEmpty\", \"isNotEmpty\", \"lt\", \"gt\", \"isBetween\"\n  ] as const,\n}; \n\n// URL Search Parameters Types\nexport interface SearchParams {\n  [key: string]: string | string[] | undefined;\n}\n\nexport interface DataTableSearchParams {\n  page?: string;\n  pageSize?: string;\n  sort?: string;\n  filters?: string;\n  visibility?: string;\n  order?: string;\n}\n\nexport interface DataTableState {\n  pagination: PaginationState;\n  sorting: SortingState;\n  columnFilters: ColumnFiltersState;\n  columnVisibility: VisibilityState;\n  columnOrder: ColumnOrderState;\n}\n\n// Utility Functions for URL Search Parameters\nexport function parseSearchParams(searchParams: SearchParams): Partial<DataTableState> {\n  const state: Partial<DataTableState> = {};\n\n  // Parse pagination\n  const page = searchParams.page ? parseInt(searchParams.page as string) - 1 : 0;\n  const pageSize = searchParams.pageSize ? parseInt(searchParams.pageSize as string) : 10;\n  state.pagination = {\n    pageIndex: Math.max(0, page),\n    pageSize: Math.max(1, pageSize),\n  };\n\n  // Parse sorting\n  if (searchParams.sort) {\n    try {\n      const sortString = searchParams.sort as string;\n      state.sorting = sortString.split(',').map(sort => {\n        const [id, desc] = sort.split(':');\n        return {\n          id,\n          desc: desc === 'desc'\n        };\n      });\n    } catch {\n      state.sorting = [];\n    }\n  } else {\n    state.sorting = [];\n  }\n\n  // Parse filters\n  if (searchParams.filters) {\n    try {\n      const filtersString = decodeURIComponent(searchParams.filters as string);\n      state.columnFilters = JSON.parse(filtersString);\n    } catch {\n      state.columnFilters = [];\n    }\n  } else {\n    state.columnFilters = [];\n  }\n\n  // Parse column visibility\n  if (searchParams.visibility) {\n    try {\n      const visibilityString = decodeURIComponent(searchParams.visibility as string);\n      state.columnVisibility = JSON.parse(visibilityString);\n    } catch {\n      state.columnVisibility = {};\n    }\n  } else {\n    state.columnVisibility = {};\n  }\n\n  // Parse column order\n  if (searchParams.order) {\n    try {\n      state.columnOrder = (searchParams.order as string).split(\",\");\n    } catch {\n      state.columnOrder = [];\n    }\n  } else {\n    state.columnOrder = [];\n  }\n\n  return state;\n}\n\nexport function serializeTableState(state: DataTableState): DataTableSearchParams {\n  const params: DataTableSearchParams = {};\n\n  // Serialize pagination\n  if (state.pagination.pageIndex > 0) {\n    params.page = (state.pagination.pageIndex + 1).toString();\n  }\n  if (state.pagination.pageSize !== 10) {\n    params.pageSize = state.pagination.pageSize.toString();\n  }\n\n  // Serialize sorting\n  if (state.sorting.length > 0) {\n    params.sort = state.sorting\n      .map(sort => `${sort.id}:${sort.desc ? 'desc' : 'asc'}`)\n      .join(',');\n  }\n\n  // Serialize filters\n  if (state.columnFilters.length > 0) {\n    params.filters = encodeURIComponent(JSON.stringify(state.columnFilters));\n  }\n\n  // Serialize column visibility (only if columns are hidden)\n  const hiddenColumns = Object.entries(state.columnVisibility).filter(([, visible]) => !visible);\n  if (hiddenColumns.length > 0) {\n    params.visibility = encodeURIComponent(JSON.stringify(state.columnVisibility));\n  }\n\n  // Serialize column order\n  if (state.columnOrder?.length > 0) {\n    params.order = state.columnOrder.join(\",\");\n  }\n\n  return params;\n}\n\nexport function updateSearchParams(\n  currentParams: URLSearchParams,\n  newParams: DataTableSearchParams\n): URLSearchParams {\n  const updatedParams = new URLSearchParams(currentParams);\n\n  // Remove existing data table params\n  updatedParams.delete('page');\n  updatedParams.delete('pageSize');\n  updatedParams.delete('sort');\n  updatedParams.delete('filters');\n  updatedParams.delete('visibility');\n  updatedParams.delete('order');\n\n  // Add new params\n  Object.entries(newParams).forEach(([key, value]) => {\n    if (value !== undefined && value !== '') {\n      updatedParams.set(key, value);\n    }\n  });\n\n  return updatedParams;\n}\n\ndeclare module \"@tanstack/react-table\" {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface ColumnMeta<TData extends RowData, TValue> {\n    label?: string;\n    placeholder?: string;\n    variant?: FilterVariant;\n    options?: Option[];\n    range?: [number, number];\n    unit?: string;\n    icon?: React.FC<React.SVGProps<SVGSVGElement>>;\n    excludeFromForm?: boolean;\n    readOnly?: boolean;\n  }\n}\n\nexport interface Option {\n  label: string;\n  value: string;\n  count?: number;\n  icon?: React.FC<React.SVGProps<SVGSVGElement>>;\n}\n\nexport type FilterOperator = DataTableConfig[\"operators\"][number];\nexport type FilterVariant = DataTableConfig[\"filterVariants\"][number];\n\nexport interface ExtendedColumnFilter<TData> {\n  id: Extract<keyof TData, string>;\n  value: string | string[] | number | boolean | Date;\n  variant: FilterVariant;\n  operator: FilterOperator;\n  filterId: string;\n}\n\n// Custom filter function that handles all our operators\nexport function customFilterFn(row: { getValue: (key: string) => unknown }, columnId: string, filterValue: { operator: string; value: unknown; variant: string }) {\n  if (!filterValue || typeof filterValue !== 'object') return true;\n  \n  const { operator, value, variant } = filterValue;\n  const cellValue = row.getValue(columnId);\n\n  // Handle empty/not empty operators first\n  if (operator === \"isEmpty\") {\n    return cellValue === null || cellValue === undefined || cellValue === \"\";\n  }\n  if (operator === \"isNotEmpty\") {\n    return cellValue !== null && cellValue !== undefined && cellValue !== \"\";\n  }\n\n  // If no value provided for other operators, don't filter\n  if (value === null || value === undefined || value === \"\") return true;\n\n  // Convert values for comparison\n  let compareValue = value;\n  \n  // Convert string numbers to actual numbers for numeric operations\n  if (variant === \"number\" && typeof value === \"string\" && value !== \"\") {\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue)) {\n      compareValue = numValue;\n    }\n  }\n  \n  // Convert date strings to Date objects for date operations\n  if (variant === \"date\" && typeof value === \"string\" && value !== \"\") {\n    compareValue = new Date(value);\n  }\n  \n  // Convert string booleans to actual booleans\n  if (variant === \"boolean\" && typeof value === \"string\") {\n    compareValue = value === \"true\";\n  }\n\n  // Handle different operators\n  switch (operator) {\n    case \"eq\": // Is\n      // Handle date comparisons for equality\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          // Compare dates by day (ignore time)\n          return cellDate.toDateString() === compareDate.toDateString();\n        }\n      }\n      return cellValue === compareValue;\n      \n    case \"ne\": // Is not\n      // Handle date comparisons for inequality\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          // Compare dates by day (ignore time)\n          return cellDate.toDateString() !== compareDate.toDateString();\n        }\n      }\n      return cellValue !== compareValue;\n      \n    case \"iLike\": // Contains (case insensitive)\n      if (typeof cellValue === \"string\" && typeof compareValue === \"string\") {\n        return cellValue.toLowerCase().includes(compareValue.toLowerCase());\n      }\n      return false;\n      \n    case \"notILike\": // Does not contain (case insensitive)\n      if (typeof cellValue === \"string\" && typeof compareValue === \"string\") {\n        return !cellValue.toLowerCase().includes(compareValue.toLowerCase());\n      }\n      return true;\n      \n    case \"lt\": // Less than / Before\n      if (typeof cellValue === \"number\" && typeof compareValue === \"number\") {\n        return cellValue < compareValue;\n      }\n      // Handle date comparisons\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          return cellDate < compareDate;\n        }\n      }\n      if (cellValue instanceof Date && compareValue instanceof Date) {\n        return cellValue < compareValue;\n      }\n      return false;\n      \n    case \"gt\": // Greater than / After\n      if (typeof cellValue === \"number\" && typeof compareValue === \"number\") {\n        return cellValue > compareValue;\n      }\n      // Handle date comparisons\n      if (variant === \"date\") {\n        const cellDate = typeof cellValue === \"string\" ? new Date(cellValue) : cellValue;\n        const compareDate = compareValue instanceof Date ? compareValue : new Date(compareValue as string);\n        if (cellDate instanceof Date && compareDate instanceof Date && !isNaN(cellDate.getTime()) && !isNaN(compareDate.getTime())) {\n          return cellDate > compareDate;\n        }\n      }\n      if (cellValue instanceof Date && compareValue instanceof Date) {\n        return cellValue > compareValue;\n      }\n      return false;\n      \n    case \"inArray\": // Has any of (for multi-select)\n      if (Array.isArray(compareValue)) {\n        return compareValue.includes(cellValue);\n      }\n      return false;\n      \n    case \"notInArray\": // Has none of (for multi-select)\n      if (Array.isArray(compareValue)) {\n        return !compareValue.includes(cellValue);\n      }\n      return true;\n      \n    case \"isBetween\": // Is between (for ranges)\n      if (Array.isArray(value) && value.length === 2) {\n        const [min, max] = value;\n        const minNum = typeof min === \"string\" ? parseFloat(min) : min;\n        const maxNum = typeof max === \"string\" ? parseFloat(max) : max;\n        \n        if (typeof cellValue === \"number\" && !isNaN(minNum as number) && !isNaN(maxNum as number)) {\n          return cellValue >= (minNum as number) && cellValue <= (maxNum as number);\n        }\n      }\n      return true;\n      \n    default:\n      return true;\n  }\n} ",
      "type": "registry:lib",
      "target": "lib/data-table.ts"
    },
    {
      "path": "registry/data-table/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/client.ts"
    },
    {
      "path": "registry/data-table/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/server.ts"
    },
    {
      "path": "registry/data-table/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { NextResponse, type NextRequest } from 'next/server'\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll()\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\n          supabaseResponse = NextResponse.next({\n            request,\n          })\n          cookiesToSet.forEach(({ name, value, options }) =>\n            supabaseResponse.cookies.set(name, value, options)\n          )\n        },\n      },\n    }\n  )\n\n  // Do not run code between createServerClient and\n  // supabase.auth.getUser(). A simple mistake could make it very hard to debug\n  // issues with users being randomly logged out.\n\n  // IMPORTANT: DO NOT REMOVE auth.getUser()\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  if (\n    !user &&\n    !request.nextUrl.pathname.startsWith('/login') &&\n    !request.nextUrl.pathname.startsWith('/auth')\n  ) {\n    // no user, potentially respond by redirecting the user to the login page\n    const url = request.nextUrl.clone()\n    url.pathname = '/auth/login'\n    return NextResponse.redirect(url)\n  }\n\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\n  // If you're creating a new response object with NextResponse.next() make sure to:\n  // 1. Pass the request in it, like so:\n  //    const myNewResponse = NextResponse.next({ request })\n  // 2. Copy over the cookies, like so:\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\n  //    the cookies!\n  // 4. Finally:\n  //    return myNewResponse\n  // If this is not done, you may be causing the browser and server to go out\n  // of sync and terminate the user's session prematurely!\n\n  return supabaseResponse\n} ",
      "type": "registry:lib",
      "target": "lib/supabase/middleware.ts"
    },
    {
      "path": "registry/data-table/app/person/page.tsx",
      "content": "import DataTablePerson from \"./_components/person-table\"\n\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const params = await searchParams\n\n  return (\n    <main className=\"px-3 py-10 w-full max-w-5xl mx-auto\">\n      <DataTablePerson searchParams={params} />\n    </main>\n  )\n}",
      "type": "registry:page",
      "target": "app/person/page.tsx"
    },
    {
      "path": "registry/data-table/app/person/_components/person-table.tsx",
      "content": "import { columns } from \"./person-columns\"\nimport { DataTable } from \"@/components/data-table/data-table\"\nimport { parseSearchParams, SearchParams } from \"@/lib/data-table\"\nimport { getPersons } from \"../_lib/queries\"\nimport { deletePersons, createPerson, updatePerson, multiUpdatePersons } from \"../_lib/actions\"\nimport { ContactAddForm, ContactEditForm, ContactMultiEditForm } from \"./person-form-wrapper\"\nimport { ColumnDef } from \"@tanstack/react-table\"\n\ninterface DataTablePersonProps {\n  searchParams?: SearchParams\n}\n\nexport default async function DataTablePerson({ \n  searchParams = {} \n}: DataTablePersonProps) {\n  const { data, count, error } = await getPersons(searchParams)\n  const { pagination } = parseSearchParams(searchParams)\n\n  if (error) {\n    // TODO: Add a toast notification\n    console.error(error)\n  }\n\n  const pageCount = Math.ceil((count ?? 0) / (pagination?.pageSize ?? 10))\n  const initialState = {\n    ...parseSearchParams(searchParams),\n    columnVisibility: {\n      first_name: false,\n      last_name: false,\n    },\n  }\n\n  // Cast the data and actions to match DataTable's expected types\n  const tableData = data as unknown as Record<string, unknown>[]\n  const tableColumns = columns as ColumnDef<Record<string, unknown>, unknown>[]\n  \n  const tableDeleteAction = deletePersons as (ids: string[]) => Promise<{ success: boolean; error?: string; deletedCount?: number }>\n  const tableCreateAction = createPerson as unknown as (data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  const tableUpdateActionSingle = updatePerson as unknown as (id: string, data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  const tableUpdateActionMulti = multiUpdatePersons as unknown as (ids: string[], data: Record<string, unknown>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  \n  // Cast the custom forms to match expected types\n  const AddForm = ContactAddForm as React.ComponentType<{\n    onSuccess?: () => void\n    onCancel?: () => void\n    createAction?: (data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  }>\n  \n  const EditFormSingle = ContactEditForm as React.ComponentType<{\n    data: Record<string, unknown>\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateAction?: (id: string, data: Record<string, unknown>) => Promise<{ success: boolean; error?: string }>\n  }>\n\n  const EditFormMulti = ContactMultiEditForm as React.ComponentType<{\n    selectedCount: number\n    onSuccess?: () => void\n    onCancel?: () => void\n    updateActionMulti?: (ids: string[], data: Record<string, unknown>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n  }>\n\n  return (\n      <DataTable \n        columns={tableColumns} \n        data={tableData} \n        pageCount={pageCount}\n        initialState={initialState}\n        deleteAction={tableDeleteAction}\n        createAction={tableCreateAction}\n        updateActionSingle={tableUpdateActionSingle}\n        updateActionMulti={tableUpdateActionMulti}\n        customAddForm={AddForm}\n        customEditFormSingle={EditFormSingle}\n        customEditFormMulti={EditFormMulti}\n      />\n  )\n}",
      "type": "registry:component",
      "target": "app/person/_components/person-table.tsx"
    },
    {
      "path": "registry/data-table/app/person/_components/person-columns.tsx",
      "content": "\"use client\"\n\nimport { ColumnDef } from \"@tanstack/react-table\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { DataTableColumnHeader } from \"@/components/data-table/data-table-column-header\"\nimport { PersonWithRelations } from \"../_lib/validations\"\nimport { AtSign, BriefcaseBusiness, Building2, IdCard, MapPin, Phone, Pilcrow } from \"lucide-react\"\n\nexport const columns: ColumnDef<PersonWithRelations>[] = [\n  {\n    id: \"select\",\n    header: ({ table }) => (\n      <Checkbox\n        checked={\n          table.getIsAllPageRowsSelected() ||\n          (table.getIsSomePageRowsSelected() && \"indeterminate\")\n        }\n        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n        aria-label=\"Select all\"\n      />\n    ),\n    cell: ({ row }) => (\n      <Checkbox\n        checked={row.getIsSelected()}\n        onCheckedChange={(value) => row.toggleSelected(!!value)}\n        aria-label=\"Select row\"\n      />\n    ),\n    enableSorting: false,\n    enableHiding: false,\n    meta: {\n      excludeFromForm: true,\n    },\n  },\n  {\n    id: \"display_name\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <IdCard className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Name\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const firstName = row.original.first_name || \"\"\n      const lastName = row.original.last_name || \"\"\n      const displayName = `${firstName} ${lastName}`.trim() || \"\"\n\n      return (\n        <div className=\"flex items-center gap-2\">\n          <span className=\"font-medium\">{displayName}</span>\n        </div>\n      )\n    },\n    meta: {\n      label: \"Name\",\n      variant: \"text\",\n      placeholder: \"Display Name...\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"first_name\",\n    header: ({ column }) => <DataTableColumnHeader column={column} title=\"First Name\" />,\n    cell: ({ row }) => {\n      const firstName = row.getValue(\"first_name\") as string\n      return <div className=\"\">{firstName || \"\"}</div>\n    },\n    meta: {\n      label: \"First Name\",\n      variant: \"text\",\n      placeholder: \"John\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"last_name\",\n    header: ({ column }) => <DataTableColumnHeader column={column} title=\"Last Name\" />,\n    cell: ({ row }) => {\n      const lastName = row.getValue(\"last_name\") as string\n      return <div className=\"\">{lastName || \"\"}</div>\n    },\n    meta: {\n      label: \"Last Name\",\n      variant: \"text\",\n      placeholder: \"Doe\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    id: \"primary_email\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <AtSign className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Email\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const emails = row.original.emails || []\n      const primaryEmail = emails.sort((a, b) => a.display_order - b.display_order)[0]\n      \n      if (!primaryEmail) return <div className=\"text-muted-foreground\"></div>\n      \n      return (\n        <div className=\"flex items-center gap-2\">\n          <Badge variant=\"blue\" className=\"text-sm font-normal\">{primaryEmail.email}</Badge>\n          {emails.length > 1 && (\n            <Badge variant=\"gray\" className=\"text-xs font-normal\">\n              +{emails.length - 1}\n            </Badge>\n          )}\n        </div>\n      )\n    },\n    meta: {\n      label: \"Email\",\n      variant: \"text\",\n      placeholder: \"john@example.com\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"description\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <Pilcrow className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Description\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const description = row.getValue(\"description\") as string\n      if (!description) return <div className=\"text-muted-foreground\"></div>\n      \n      // Truncate description for display\n      const truncated = description.length > 50 ? description.substring(0, 50) + \"...\" : description\n      \n      return (\n        <div className=\"text-sm text-muted-foreground max-w-[200px] truncate\" title={description}>\n          {truncated}\n        </div>\n      )\n    },\n    meta: {\n      label: \"Description\",\n      variant: \"text\",\n      placeholder: \"Additional notes about this contact...\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    id: \"company_name\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <Building2 className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Company\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const company = row.original.company\n      if (!company) return <div className=\"text-muted-foreground\"></div>\n      return <Badge variant=\"outline\" className=\"text-sm font-normal\">{company.name}</Badge>\n    },\n    meta: {\n      label: \"Company\",\n      variant: \"text\",\n      placeholder: \"Company ABC\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"job_title\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <BriefcaseBusiness className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Title\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const jobTitle = row.getValue(\"job_title\") as string\n      return <div className=\"text-sm\">{jobTitle || \"\"}</div>\n    },\n    meta: {\n      label: \"Job Title\",\n      variant: \"text\",\n      placeholder: \"Software Engineer\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    id: \"primary_phone\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <Phone className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Phone\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const phones = row.original.phones || []\n      const primaryPhone = phones.sort((a, b) => a.display_order - b.display_order)[0]\n      \n      if (!primaryPhone) return <div className=\"text-muted-foreground\"></div>\n      \n      return (\n        <div className=\"flex items-center gap-2\">\n          <Badge variant=\"blue\" className=\"text-sm font-normal\">{primaryPhone.phone}</Badge>\n          {phones.length > 1 && (\n            <Badge variant=\"gray\" className=\"text-xs font-normal\">\n              +{phones.length - 1}\n            </Badge>\n          )}\n        </div>\n      )\n    },\n    meta: {\n      label: \"Phone\",\n      variant: \"text\",\n      placeholder: \"(123) 456-7890\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    id: \"location\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <MapPin className=\"size-4 shrink-0\" strokeWidth={1.5} />\n        <DataTableColumnHeader column={column} title=\"Location\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const city = row.original.city || \"\"\n      const state = row.original.state || \"\"\n      const location = `${city}${city && state ? ', ' : ''}${state}`.trim()\n      \n      if (!location) return <div className=\"text-muted-foreground\"></div>\n      \n      return <div className=\"text-sm text-muted-foreground\">{location}</div>\n    },\n    meta: {\n      label: \"Location\",\n      variant: \"text\",\n      placeholder: \"San Francisco, CA\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"linkedin\",\n    header: ({ column }) => (\n      <div className=\"flex items-center gap-2\">\n        <div className=\"border border-muted-foreground rounded size-4 flex items-center justify-center\">\n          <span className=\"text-xs\">in</span>\n        </div>\n        <DataTableColumnHeader column={column} title=\"LinkedIn\" />\n      </div>\n    ),\n    cell: ({ row }) => {\n      const linkedin = row.getValue(\"linkedin\") as string\n      if (!linkedin) return <div className=\"text-muted-foreground\"></div>\n      \n      // Extract username from LinkedIn URL\n      const match = linkedin.match(/linkedin\\.com\\/in\\/([^\\/\\?]+)/)\n      if (match) {\n        return <Badge variant=\"blue\" className=\"text-sm font-normal\">@{match[1]}</Badge>\n      }\n      \n      return (\n        <a \n          href={linkedin} \n          target=\"_blank\" \n          rel=\"noopener noreferrer\"\n          className=\"text-blue-600 hover:text-blue-800 text-sm\"\n        >\n          {linkedin}\n        </a>\n      )\n    },\n    meta: {\n      label: \"LinkedIn\",\n      variant: \"text\",\n      placeholder: \"https://www.linkedin.com/in/username\",\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"created_at\",\n    header: ({ column }) => <DataTableColumnHeader column={column} title=\"Created\" />,\n    cell: ({ row }) => {\n      const createdAt = row.getValue(\"created_at\") as string\n      if (!createdAt) return <div className=\"text-muted-foreground\"></div>\n      \n      const date = new Date(createdAt)\n      const formatted = new Intl.DateTimeFormat(\"en-US\", {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\",\n      }).format(date)\n      \n      return <div className=\"text-sm text-muted-foreground\">{formatted}</div>\n    },\n    meta: {\n      label: \"Created\",\n      variant: \"date\",\n      readOnly: true,\n    },\n    enableColumnFilter: true,\n  },\n  {\n    accessorKey: \"updated_at\",\n    header: ({ column }) => <DataTableColumnHeader column={column} title=\"Updated\" />,\n    cell: ({ row }) => {\n      const updatedAt = row.getValue(\"updated_at\") as string\n      if (!updatedAt) return <div className=\"text-muted-foreground\"></div>\n      \n      const date = new Date(updatedAt)\n      const formatted = new Intl.DateTimeFormat(\"en-US\", {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\",\n      }).format(date)\n      \n      return <div className=\"text-sm text-muted-foreground\">{formatted}</div>\n    },\n    meta: {\n      label: \"Updated\",\n      variant: \"date\",\n      readOnly: true,\n    },\n    enableColumnFilter: true,\n  },\n]",
      "type": "registry:component",
      "target": "app/person/_components/person-columns.tsx"
    },
    {
      "path": "registry/data-table/app/person/_components/person-form.tsx",
      "content": "\"use client\";\n\nimport { Input } from \"@/components/ui/input\";\nimport { AtSign, BriefcaseBusiness, Building2, GripVertical, IdCard, MapPin, Phone, Pilcrow, Plus, X, Check } from \"lucide-react\";\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/components/ui/popover\";\nimport { useState, useEffect, forwardRef, useRef } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator } from \"@/components/ui/command\";\nimport { cn } from \"@/lib/utils\";\nimport {\n    DndContext,\n    closestCenter,\n    KeyboardSensor,\n    PointerSensor,\n    useSensor,\n    useSensors,\n    DragEndEvent,\n} from '@dnd-kit/core';\nimport {\n    arrayMove,\n    SortableContext,\n    sortableKeyboardCoordinates,\n    verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport {\n    useSortable,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from \"@/components/ui/dialog\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Label } from \"@/components/ui/label\";\nimport { Company } from '../_lib/validations';\nimport { Separator } from \"@/components/ui/separator\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\n\nexport interface PersonFormProps {\n    /**\n     * Initial first name value\n     */\n    initialFirstName?: string;\n    /**\n     * Initial last name value\n     */\n    initialLastName?: string;\n    /**\n     * Initial email addresses\n     */\n    initialEmails?: string[];\n    /**\n     * Initial phone numbers\n     */\n    initialPhones?: string[];\n    /**\n     * Initial city value\n     */\n    initialCity?: string;\n    /**\n     * Initial state value\n     */\n    initialState?: string;\n    /**\n     * Initial company value\n     */\n    initialCompany?: string;\n    /**\n     * Initial description value\n     */\n    initialDescription?: string;\n    /**\n     * Initial LinkedIn profile URL\n     */\n    initialLinkedin?: string;\n    /**\n     * Initial job title value\n     */\n    initialJobTitle?: string;\n    /**\n     * List of available companies for selection\n     */\n    availableCompanies?: Company[];\n    /**\n     * Callback fired when form data changes\n     */\n    onChange?: (data: {\n        firstName: string;\n        lastName: string;\n        emails: string[];\n        phones: string[];\n        city: string;\n        state: string;\n        company: string;\n        description: string;\n        linkedin: string;\n        jobTitle: string;\n    }) => void;\n    /**\n     * Custom CSS class name\n     */\n    className?: string;\n}\n\ninterface SortableEmailItemProps {\n    id: string;\n    email: string;\n    index: number;\n    onUpdate: (index: number, value: string) => void;\n    onRemove: (index: number) => void;\n}\n\nconst SortableEmailItem = forwardRef<HTMLInputElement, SortableEmailItemProps>(({ id, email, index, onUpdate, onRemove }, ref) => {\n    const {\n        attributes,\n        listeners,\n        setNodeRef,\n        transform,\n        transition,\n        isDragging,\n    } = useSortable({ id });\n\n    const style = {\n        transform: CSS.Transform.toString(transform),\n        transition,\n        opacity: isDragging ? 0.5 : 1,\n    };\n\n    return (\n        <div\n            ref={setNodeRef}\n            style={style}\n            className=\"flex flex-row gap-1 items-center\"\n        >\n            <div\n                {...attributes}\n                {...listeners}\n                className=\"cursor-grab active:cursor-grabbing\"\n            >\n                <GripVertical className=\"size-4 shrink-0\" strokeWidth={1.5} />\n            </div>\n            <Input \n                ref={ref}\n                className=\"text-xs flex-1\" \n                placeholder=\"email@example.com\" \n                value={email}\n                onChange={(e) => onUpdate(index, e.target.value)}\n            />\n            <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0\"\n                onClick={() => onRemove(index)}\n            >\n                <X className=\"size-3\" strokeWidth={1.5} />\n            </Button>\n        </div>\n    );\n});\nSortableEmailItem.displayName = 'SortableEmailItem';\n\ninterface SortablePhoneItemProps {\n    id: string;\n    phone: string;\n    index: number;\n    onUpdate: (index: number, value: string) => void;\n    onRemove: (index: number) => void;\n}\n\nconst SortablePhoneItem = forwardRef<HTMLInputElement, SortablePhoneItemProps>(({ id, phone, index, onUpdate, onRemove }, ref) => {\n    const {\n        attributes,\n        listeners,\n        setNodeRef,\n        transform,\n        transition,\n        isDragging,\n    } = useSortable({ id });\n\n    const style = {\n        transform: CSS.Transform.toString(transform),\n        transition,\n        opacity: isDragging ? 0.5 : 1,\n    };\n\n    return (\n        <div\n            ref={setNodeRef}\n            style={style}\n            className=\"flex flex-row gap-1 items-center\"\n        >\n            <div\n                {...attributes}\n                {...listeners}\n                className=\"cursor-grab active:cursor-grabbing\"\n            >\n                <GripVertical className=\"size-4 shrink-0\" strokeWidth={1.5} />\n            </div>\n            <Input \n                ref={ref}\n                className=\"text-xs flex-1\" \n                placeholder=\"+1 (555) 123-4567\" \n                value={phone}\n                onChange={(e) => onUpdate(index, e.target.value)}\n            />\n            <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0\"\n                onClick={() => onRemove(index)}\n            >\n                <X className=\"size-3\" strokeWidth={1.5} />\n            </Button>\n        </div>\n    );\n});\nSortablePhoneItem.displayName = 'SortablePhoneItem';\n\nexport default function PersonForm({\n    initialFirstName = \"\",\n    initialLastName = \"\",\n    initialEmails = [],\n    initialPhones = [],\n    initialCity = \"\",\n    initialState = \"\",\n    initialCompany = \"\",\n    initialDescription = \"\",\n    initialLinkedin = \"\",\n    initialJobTitle = \"\",\n    availableCompanies,\n    onChange,\n    className\n}: PersonFormProps = {}) {\n    const [firstName, setFirstName] = useState(initialFirstName);\n    const [lastName, setLastName] = useState(initialLastName);\n    const [emails, setEmails] = useState<string[]>(initialEmails);\n    const [emailPopoverOpen, setEmailPopoverOpen] = useState(false);\n    const [focusLastEmail, setFocusLastEmail] = useState(false);\n    const lastEmailInputRef = useRef<HTMLInputElement>(null);\n    const [phones, setPhones] = useState<string[]>(initialPhones);\n    const [phonePopoverOpen, setPhonePopoverOpen] = useState(false);\n    const [focusLastPhone, setFocusLastPhone] = useState(false);\n    const lastPhoneInputRef = useRef<HTMLInputElement>(null);\n    const [city, setCity] = useState(initialCity);\n    const [state, setState] = useState(initialState);\n    const [company, setCompany] = useState(initialCompany);\n    const [companyOpen, setCompanyOpen] = useState(false);\n    const [addCompanyDialogOpen, setAddCompanyDialogOpen] = useState(false);\n    const [newCompanyName, setNewCompanyName] = useState(\"\");\n    const [newCompanyDescription, setNewCompanyDescription] = useState(\"\");\n    const [description, setDescription] = useState(initialDescription);\n    const [isDescriptionFocused, setIsDescriptionFocused] = useState(false);\n    const [linkedin, setLinkedin] = useState(initialLinkedin);\n    const [jobTitle, setJobTitle] = useState(initialJobTitle);\n    const [namePopoverOpen, setNamePopoverOpen] = useState(false);\n    const [locationPopoverOpen, setLocationPopoverOpen] = useState(false);\n    const [linkedinPopoverOpen, setLinkedinPopoverOpen] = useState(false);\n\n    const [companies, setCompanies] = useState(availableCompanies || []);\n\n    useEffect(() => {\n        if (focusLastEmail) {\n            setTimeout(() => {\n                lastEmailInputRef.current?.focus();\n            }, 100); // Delay to allow popover animation to complete\n            setFocusLastEmail(false);\n        }\n    }, [focusLastEmail]);\n\n    useEffect(() => {\n        if (focusLastPhone) {\n            setTimeout(() => {\n                lastPhoneInputRef.current?.focus();\n            }, 100); // Delay to allow popover animation to complete\n            setFocusLastPhone(false);\n        }\n    }, [focusLastPhone]);\n\n    useEffect(() => {\n        setCompanies(availableCompanies || [])\n    }, [availableCompanies])\n\n    const sensors = useSensors(\n        useSensor(PointerSensor),\n        useSensor(KeyboardSensor, {\n            coordinateGetter: sortableKeyboardCoordinates,\n        })\n    );\n\n    // Call onChange callback when form data changes\n    useEffect(() => {\n        if (onChange) {\n            onChange({\n                firstName,\n                lastName,\n                emails,\n                phones,\n                city,\n                state,\n                company,\n                description,\n                linkedin,\n                jobTitle\n            });\n        }\n    }, [firstName, lastName, emails, phones, city, state, company, description, linkedin, jobTitle, onChange]);\n\n    const getDisplayName = () => {\n        const fullName = `${firstName} ${lastName}`.trim();\n        return fullName || \"Set Name...\";\n    };\n\n    const getDisplayLinkedin = () => {\n        if (!linkedin) return \"Set LinkedIn...\";\n        \n        // Extract username from LinkedIn URL\n        const match = linkedin.match(/linkedin\\.com\\/in\\/([^\\/\\?]+)/);\n        if (match) {\n            return <Badge variant=\"blue\" className=\"text-sm\">@{match[1]}</Badge>;\n        }\n        \n        // If it's not a full URL, just display as is\n        return linkedin;\n    };\n\n    const getDisplayLocation = () => {\n        const fullLocation = `${city}${city && state ? ', ' : ''}${state}`.trim();\n        return fullLocation || \"Set Primary Location...\";\n    };\n\n    const getDisplayEmails = () => {\n        const nonEmptyEmails = emails.filter(email => email.trim() !== \"\");\n        if (nonEmptyEmails.length === 0) return \"Set Email addresses...\";\n        if (nonEmptyEmails.length === 1) return <Badge variant=\"blue\" className=\"text-sm\">{nonEmptyEmails[0]}</Badge>;\n        return (\n            <div className=\"flex items-center gap-2\">\n                <Badge variant=\"blue\" className=\"text-sm\">{nonEmptyEmails[0]}</Badge>\n                <Badge variant=\"gray\" className=\"text-xs\">\n                    +{nonEmptyEmails.length - 1}\n                </Badge>\n            </div>\n        );\n    };\n\n    const getDisplayPhones = () => {\n        const nonEmptyPhones = phones.filter(phone => phone.trim() !== \"\");\n        if (nonEmptyPhones.length === 0) return \"Set Phone numbers...\";\n        if (nonEmptyPhones.length === 1) return <Badge variant=\"blue\" className=\"text-sm\">{nonEmptyPhones[0]}</Badge>;\n        return (\n            <div className=\"flex items-center gap-2\">\n                <Badge variant=\"blue\" className=\"text-sm\">{nonEmptyPhones[0]}</Badge>\n                <Badge variant=\"gray\" className=\"text-xs\">\n                    +{nonEmptyPhones.length - 1}\n                </Badge>\n            </div>\n        );\n    };\n\n    const addEmail = () => {\n        setEmails([...emails, \"\"]);\n        setFocusLastEmail(true);\n    };\n\n    const updateEmail = (index: number, value: string) => {\n        const newEmails = [...emails];\n        newEmails[index] = value;\n        setEmails(newEmails);\n    };\n\n    const removeEmail = (index: number) => {\n        const newEmails = emails.filter((_, i) => i !== index);\n        setEmails(newEmails);\n    };\n\n    const handleEmailPopoverOpenChange = (open: boolean) => {\n        setEmailPopoverOpen(open);\n        if (open && emails.length === 0) {\n            addEmail();\n        }\n    };\n\n    const addPhone = () => {\n        setPhones([...phones, \"\"]);\n        setFocusLastPhone(true);\n    };\n\n    const updatePhone = (index: number, value: string) => {\n        const newPhones = [...phones];\n        newPhones[index] = value;\n        setPhones(newPhones);\n    };\n\n    const removePhone = (index: number) => {\n        const newPhones = phones.filter((_, i) => i !== index);\n        setPhones(newPhones);\n    };\n\n    const handlePhonePopoverOpenChange = (open: boolean) => {\n        setPhonePopoverOpen(open);\n        if (open && phones.length === 0) {\n            addPhone();\n        }\n    };\n\n    const handleDragEnd = (event: DragEndEvent) => {\n        const { active, over } = event;\n\n        if (active.id !== over?.id) {\n            setEmails((items) => {\n                const oldIndex = items.findIndex((_, index) => `email-${index}` === active.id);\n                const newIndex = items.findIndex((_, index) => `email-${index}` === over?.id);\n\n                return arrayMove(items, oldIndex, newIndex);\n            });\n        }\n    };\n\n    const handlePhoneDragEnd = (event: DragEndEvent) => {\n        const { active, over } = event;\n\n        if (active.id !== over?.id) {\n            setPhones((items) => {\n                const oldIndex = items.findIndex((_, index) => `phone-${index}` === active.id);\n                const newIndex = items.findIndex((_, index) => `phone-${index}` === over?.id);\n\n                return arrayMove(items, oldIndex, newIndex);\n            });\n        }\n    };\n\n    const handleCreateCompany = () => {\n        if (newCompanyName.trim()) {\n            setCompany(newCompanyName.trim());\n            setNewCompanyName(\"\");\n            setNewCompanyDescription(\"\");\n            setAddCompanyDialogOpen(false);\n            setCompanyOpen(false);\n        }\n    };\n\n    const handleAddCompanyDialogKeyDown = (e: React.KeyboardEvent) => {\n        if (e.key === \"Escape\") {\n            setAddCompanyDialogOpen(false);\n            setNewCompanyName(\"\");\n            setNewCompanyDescription(\"\");\n        } else if ((e.metaKey || e.ctrlKey) && e.key === \"Enter\") {\n            e.preventDefault();\n            handleCreateCompany();\n        }\n    };\n\n    const handlePopoverKeyDown = (e: React.KeyboardEvent, closePopover: () => void) => {\n        if (e.key === \"Enter\") {\n            const activeElement = document.activeElement;\n            if (activeElement && activeElement.tagName === \"BUTTON\") {\n                // If a button is focused, click it\n                (activeElement as HTMLButtonElement).click();\n            } else {\n                // Otherwise, close the popover\n                closePopover();\n            }\n        }\n    };\n\n    return (\n        <div className={cn(\"@container flex flex-col gap-2 text-foreground w-full\", className)}>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <IdCard className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Name</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                <Popover open={namePopoverOpen} onOpenChange={setNamePopoverOpen}>\n                    <PopoverTrigger className={cn(\n                        \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                        !firstName && !lastName && \"text-muted-foreground/80\"\n                    )}>\n                        {getDisplayName()}\n                    </PopoverTrigger>\n                    <PopoverContent \n                        className=\"p-3 rounded-xl\" \n                        align=\"start\"\n                        onKeyDown={(e) => handlePopoverKeyDown(e, () => setNamePopoverOpen(false))}\n                    >\n                        <div className=\"flex flex-col gap-4\">\n                            <div className=\"flex flex-col gap-1 \">\n                                <div className=\"text-xs text-muted-foreground\">First Name</div>\n                                <Input \n                                    className=\"text-xs\" \n                                    placeholder=\"Enter first name...\" \n                                    value={firstName}\n                                    onChange={(e) => setFirstName(e.target.value)}\n                                />\n                            </div>\n                            <div className=\"flex flex-col gap-1\">\n                                <div className=\"text-xs text-muted-foreground\">Last Name</div>\n                                <Input \n                                    className=\"text-xs\" \n                                    placeholder=\"Enter last name..\" \n                                    value={lastName}\n                                    onChange={(e) => setLastName(e.target.value)}\n                                />\n                            </div>\n                        </div>\n                    </PopoverContent>\n                </Popover>\n                </div>\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <AtSign className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Email</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                <Popover open={emailPopoverOpen} onOpenChange={handleEmailPopoverOpenChange}>\n                    <PopoverTrigger className={cn(\n                        \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                        emails.filter(email => email.trim() !== \"\").length === 0 && \"text-muted-foreground/80\"\n                    )}>\n                        {getDisplayEmails()}\n                    </PopoverTrigger>\n                    <PopoverContent \n                        className=\"p-2  rounded-xl\" \n                        align=\"start\"\n                        onKeyDown={(e) => handlePopoverKeyDown(e, () => setEmailPopoverOpen(false))}\n                    >\n                        <div className=\"flex flex-col gap-2\">\n                            <DndContext\n                                sensors={sensors}\n                                collisionDetection={closestCenter}\n                                onDragEnd={handleDragEnd}\n                            >\n                                <SortableContext\n                                    items={emails.map((_, index) => `email-${index}`)}\n                                    strategy={verticalListSortingStrategy}\n                                >\n                                    {emails.map((email, index) => (\n                                        <SortableEmailItem\n                                            key={`email-${index}`}\n                                            id={`email-${index}`}\n                                            email={email}\n                                            index={index}\n                                            onUpdate={updateEmail}\n                                            onRemove={removeEmail}\n                                            ref={index === emails.length - 1 ? lastEmailInputRef : null}\n                                        />\n                                    ))}\n                                </SortableContext>\n                            </DndContext>\n                            <Separator\n                                className=\"\"\n                            />\n                            <Button \n                                variant=\"secondary\" \n                                className=\"flex flex-row gap-1 items-center justify-start rounded-t-none\"\n                                onClick={addEmail}\n                            >\n                                <Plus className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                                <span className=\"text-xs\">Add Email</span>\n                            </Button>\n                        </div>\n                    </PopoverContent>\n                </Popover>\n                </div>\n            </div>\n    \n            <div className=\"flex items-start gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] pt-3 text-muted-foreground\">\n                    <Pilcrow className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Description</span>\n                </div>\n                <textarea \n                    className={cn(\n                        \"w-full min-w-0 text-left hover:bg-secondary rounded-md py-2 px-2 resize-none focus:outline-none focus:ring-1 focus:ring-ring min-h-10\",\n                        !isDescriptionFocused && \"overflow-hidden whitespace-nowrap text-ellipsis\"\n                    )}\n                    placeholder=\"Set Description...\"\n                    rows={1}\n                    value={description}\n                    onChange={(e) => setDescription(e.target.value)}\n                    onFocus={(e) => {\n                        setIsDescriptionFocused(true);\n                        setTimeout(() => {\n                            const target = e.target as HTMLTextAreaElement;\n                            target.style.height = 'auto';\n                            target.style.height = Math.max(36, target.scrollHeight) + 'px';\n                        }, 0);\n                    }}\n                    onBlur={(e) => {\n                        setIsDescriptionFocused(false);\n                        const target = e.target as HTMLTextAreaElement;\n                        target.style.height = '36px';\n                    }}\n                    onInput={(e) => {\n                        if (isDescriptionFocused) {\n                            const target = e.target as HTMLTextAreaElement;\n                            target.style.height = 'auto';\n                            target.style.height = Math.max(36, target.scrollHeight) + 'px';\n                        }\n                    }}\n                    style={{\n                        height: isDescriptionFocused ? 'auto' : '36px'\n                    }}\n                />\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <Building2 className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Company</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                    <Popover open={companyOpen} onOpenChange={setCompanyOpen}>\n                        <PopoverTrigger className={cn(\n                            \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                            !company && \"text-muted-foreground/80\"\n                        )}>\n                            {company ? <Badge variant=\"outline\" className=\"text-sm\">{company}</Badge> : \"Set Company...\"}\n                        </PopoverTrigger>\n                        <PopoverContent \n                            className=\"p-0 rounded-xl\" \n                            align=\"start\"\n                            onKeyDown={(e) => handlePopoverKeyDown(e, () => setCompanyOpen(false))}\n                        >\n                            <Command className=\"w-full rounded-xl\">\n                                <CommandInput placeholder=\"Search companies...\" />\n                                <ScrollArea className=\"h-60 pr-2\">\n                                    <CommandList className=\"max-h-none overflow-hidden\">\n                                        <CommandEmpty>No company found.</CommandEmpty>\n                                        <CommandGroup>\n                                            {companies.map((companyData) => (\n                                                <CommandItem\n                                                    key={companyData.id}\n                                                    value={companyData.name}\n                                                    onSelect={(currentValue) => {\n                                                        setCompany(company === currentValue ? \"\" : currentValue);\n                                                        setCompanyOpen(false);\n                                                    }}\n                                                >\n                                                    <Check\n                                                        className={cn(\n                                                            \"mr-2 h-4 w-4\",\n                                                            company === companyData.name ? \"opacity-100\" : \"opacity-0\"\n                                                        )}\n                                                    />\n                                                    {companyData.name}\n                                                </CommandItem>\n                                            ))}\n                                        </CommandGroup>\n                                    </CommandList>\n                                </ScrollArea>\n                                <CommandSeparator />\n                                <div className=\"p-1 h-9\">\n                                    <Button \n                                        variant=\"secondary\" \n                                        size=\"sm\"\n                                        className=\"w-full h-full justify-start rounded-t-none text-muted-foreground\"\n                                        onClick={() => {\n                                            setCompanyOpen(false);\n                                            setAddCompanyDialogOpen(true);\n                                        }}\n                                    >\n                                        <Plus className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                                        <span className=\"text-xs\">Add Company</span>\n                                    </Button>\n                                </div>\n                            </Command>\n                        </PopoverContent>\n                    </Popover>\n                </div>\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <BriefcaseBusiness className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Title</span>\n                </div>\n                <input \n                    className=\"w-full min-w-0 text-left hover:bg-secondary rounded-md py-2 px-2 truncate\" \n                    placeholder=\"Set Job title...\" \n                    value={jobTitle}\n                    onChange={(e) => setJobTitle(e.target.value)}\n                />\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <Phone className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Phone</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                <Popover open={phonePopoverOpen} onOpenChange={handlePhonePopoverOpenChange}>\n                    <PopoverTrigger className={cn(\n                        \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                        phones.filter(phone => phone.trim() !== \"\").length === 0 && \"text-muted-foreground/80\"\n                    )}>\n                        {getDisplayPhones()}\n                    </PopoverTrigger>\n                    <PopoverContent \n                        className=\"p-2 rounded-xl\" \n                        align=\"start\"\n                        onKeyDown={(e) => handlePopoverKeyDown(e, () => setPhonePopoverOpen(false))}\n                    >\n                        <div className=\"flex flex-col gap-2\">\n                            <DndContext\n                                sensors={sensors}\n                                collisionDetection={closestCenter}\n                                onDragEnd={handlePhoneDragEnd}\n                            >\n                                <SortableContext\n                                    items={phones.map((_, index) => `phone-${index}`)}\n                                    strategy={verticalListSortingStrategy}\n                                >\n                                    {phones.map((phone, index) => (\n                                        <SortablePhoneItem\n                                            key={`phone-${index}`}\n                                            id={`phone-${index}`}\n                                            phone={phone}\n                                            index={index}\n                                            onUpdate={updatePhone}\n                                            onRemove={removePhone}\n                                            ref={index === phones.length - 1 ? lastPhoneInputRef : null}\n                                        />\n                                    ))}\n                                </SortableContext>\n                            </DndContext>\n                            <Separator />\n                            <Button \n                                variant=\"secondary\" \n                                className=\"flex flex-row gap-1 items-center justify-start rounded-t-none\"\n                                onClick={addPhone}\n                            >\n                                <Plus className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                                <span className=\"text-xs\">Add Phone number</span>\n                            </Button>\n                        </div>\n                    </PopoverContent>\n                </Popover>\n                </div>\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <MapPin className=\"size-4 shrink-0\" strokeWidth={1.5} />\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">Location</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                <Popover open={locationPopoverOpen} onOpenChange={setLocationPopoverOpen}>\n                    <PopoverTrigger className={cn(\n                        \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                        !city && !state && \"text-muted-foreground/80\"\n                    )}>\n                        {getDisplayLocation()}\n                    </PopoverTrigger>\n                    <PopoverContent \n                        className=\"p-3 rounded-xl\" \n                        align=\"start\"\n                        onKeyDown={(e) => handlePopoverKeyDown(e, () => setLocationPopoverOpen(false))}\n                    >\n                        <div className=\"flex flex-col gap-4\">\n                            <div className=\"flex flex-col gap-1\">\n                                <div className=\"text-xs text-muted-foreground\">City</div>\n                                <Input \n                                    className=\"text-xs\" \n                                    placeholder=\"Enter city...\" \n                                    value={city}\n                                    onChange={(e) => setCity(e.target.value)}\n                                />\n                            </div>\n                            <div className=\"flex flex-col gap-1\">\n                                <div className=\"text-xs text-muted-foreground\">State</div>\n                                <Input \n                                    className=\"text-xs\" \n                                    placeholder=\"Enter state...\" \n                                    value={state}\n                                    onChange={(e) => setState(e.target.value)}\n                                />\n                            </div>\n                        </div>\n                    </PopoverContent>\n                </Popover>\n                </div>\n            </div>\n            <div className=\"flex items-center gap-2 justify-between\">\n                <div className=\"flex items-center gap-2 text-sm @max-sm:w-8 w-[10rem] text-muted-foreground\">\n                    <div className=\"border border-muted-foreground rounded size-4 flex items-center justify-center\">\n                        <span className=\"text-xs\">in</span>\n                    </div>\n                    <span className=\"whitespace-nowrap @max-sm:hidden\">LinkedIn</span>\n                </div>\n                <div className=\"w-full min-w-0\">\n                    <Popover open={linkedinPopoverOpen} onOpenChange={setLinkedinPopoverOpen}>\n                        <PopoverTrigger className={cn(\n                            \"w-full text-left hover:bg-secondary rounded-md py-2 px-2 truncate\",\n                            !linkedin && \"text-muted-foreground/80\"\n                        )}>\n                            {getDisplayLinkedin()}\n                        </PopoverTrigger>\n                        <PopoverContent \n                            className=\"p-3 rounded-xl\" \n                            align=\"start\"\n                            onKeyDown={(e) => handlePopoverKeyDown(e, () => setLinkedinPopoverOpen(false))}\n                        >\n                            <div className=\"flex flex-col gap-1\">\n                                <div className=\"text-xs text-muted-foreground\">LinkedIn Profile URL</div>\n                                <Input \n                                    className=\"text-xs\" \n                                    placeholder=\"https://www.linkedin.com/in/username\" \n                                    value={linkedin}\n                                    onChange={(e) => setLinkedin(e.target.value)}\n                                />\n                            </div>\n                        </PopoverContent>\n                    </Popover>\n                </div>\n            </div>\n            <Dialog open={addCompanyDialogOpen} onOpenChange={setAddCompanyDialogOpen}>\n                <DialogContent className=\"sm:max-w-[425px]\" onKeyDown={handleAddCompanyDialogKeyDown}>\n                    <DialogHeader>\n                        <DialogTitle>Add New Company</DialogTitle>\n                    </DialogHeader>\n                    <div className=\"grid gap-4 py-4\">\n                        <div className=\"grid gap-2\">\n                            <Label htmlFor=\"company-name\">Name</Label>\n                            <Input\n                                id=\"company-name\"\n                                value={newCompanyName}\n                                onChange={(e) => setNewCompanyName(e.target.value)}\n                                placeholder=\"Enter company name...\"\n                                autoFocus\n                            />\n                        </div>\n                        <div className=\"grid gap-2\">\n                            <Label htmlFor=\"company-description\">Description</Label>\n                            <Textarea\n                                id=\"company-description\"\n                                value={newCompanyDescription}\n                                onChange={(e) => setNewCompanyDescription(e.target.value)}\n                                placeholder=\"Enter company description...\"\n                                rows={3}\n                            />\n                        </div>\n                    </div>\n                    <DialogFooter>\n                        <Button \n                            variant=\"outline\" \n                            onClick={() => {\n                                setAddCompanyDialogOpen(false);\n                                setNewCompanyName(\"\");\n                                setNewCompanyDescription(\"\");\n                            }}\n                        >\n                            Cancel\n                        </Button>\n                        <Button onClick={handleCreateCompany} disabled={!newCompanyName.trim()}>\n                            Create Record\n                        </Button>\n                    </DialogFooter>\n                </DialogContent>\n            </Dialog>\n        </div>\n    );\n}",
      "type": "registry:component",
      "target": "app/person/_components/person-form.tsx"
    },
    {
      "path": "registry/data-table/app/person/_components/person-form-wrapper.tsx",
      "content": "\"use client\"\n\nimport { useState, useCallback, useEffect } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport PersonForm from \"./person-form\"\nimport { PersonWithRelations, Company } from \"../_lib/validations\"\nimport { Button } from \"@/components/ui/button\"\nimport { X, Plus, Save } from \"lucide-react\"\nimport { toast } from \"sonner\"\nimport { getCompanies } from \"../_lib/actions\"\n\ninterface PersonFormData {\n  firstName: string\n  lastName: string\n  emails: string[]\n  phones: string[]\n  city: string\n  state: string\n  company: string\n  description: string\n  linkedin: string\n  jobTitle: string\n}\n\n// Helper function to transform form data to database format\nfunction transformFormDataToContact(formData: PersonFormData): Partial<PersonWithRelations> & { _emails?: string[]; _phones?: string[], company_name?: string } {\n  const contactData: Partial<PersonWithRelations> & { _emails?: string[]; _phones?: string[], company_name?: string } = {\n    first_name: formData.firstName,\n    last_name: formData.lastName,\n    city: formData.city,\n    state: formData.state,\n    description: formData.description,\n    linkedin: formData.linkedin,\n    job_title: formData.jobTitle,\n    company_name: formData.company,\n  }\n\n  // Handle company (would need to lookup company ID or create new company)\n  // For now, we'll just set company_id to null\n  // In a real implementation, you'd need to find or create the company\n  // contactData.company_id = null\n\n  // Handle emails and phones (these would be handled separately through related tables)\n  // For the MVP, we'll store them in the onChange callback and handle them in the action\n  contactData._emails = formData.emails.filter(email => email.trim() !== '')\n  contactData._phones = formData.phones.filter(phone => phone.trim() !== '')\n\n  return contactData\n}\n\n// Add Form Wrapper\nexport function ContactAddForm({\n  onSuccess,\n  onCancel,\n  createAction\n}: {\n  onSuccess?: () => void\n  onCancel?: () => void\n  createAction?: (data: Partial<PersonWithRelations>) => Promise<{ success: boolean; error?: string }>\n}) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [formData, setFormData] = useState<PersonFormData | null>(null)\n  const [companies, setCompanies] = useState<Company[]>([])\n\n  useEffect(() => {\n    async function fetchCompanies() {\n      const { data, error } = await getCompanies()\n      if (error) {\n        toast.error(\"Could not fetch companies.\")\n        console.error(error)\n      } else if (data) {\n        setCompanies(data)\n      }\n    }\n    fetchCompanies()\n  }, [])\n\n  const handleFormDataChange = useCallback((data: PersonFormData) => {\n    setFormData(data)\n  }, [])\n\n  const handleSubmit = async () => {\n    if (!formData || !createAction) return\n\n    setIsSubmitting(true)\n    try {\n      const contactData = transformFormDataToContact(formData)\n      const result = await createAction(contactData)\n      \n      if (result.success) {\n        router.refresh()\n        onSuccess?.()\n      } else {\n        console.error(\"Failed to create contact:\", result.error)\n        toast.error(\"Failed to create contact\", { description: result.error })\n      }\n    } catch (error) {\n      console.error(\"Error creating contact:\", error)\n      toast.error(\"An unexpected error occurred while creating the contact.\")\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        <PersonForm\n          onChange={handleFormDataChange}\n          availableCompanies={companies}\n        />\n      </div>\n      \n      <div className=\"flex justify-between gap-2 p-4 border-t bg-background\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={onCancel}\n          className=\"w-1/2\"\n        >\n          <X className=\"size-4 shrink-0\" /> Cancel\n        </Button>\n        <Button\n          onClick={handleSubmit}\n          disabled={isSubmitting || !formData}\n          className=\"w-1/2\"\n        >\n          <Plus className=\"size-4 shrink-0\" />\n          {isSubmitting ? \"Adding...\" : \"Add Contact\"}\n        </Button>\n      </div>\n    </div>\n  )\n}\n\n// Edit Form Wrapper\nexport function ContactEditForm({\n  data,\n  onSuccess,\n  onCancel,\n  updateAction\n}: {\n  data: PersonWithRelations\n  onSuccess?: () => void\n  onCancel?: () => void\n  updateAction?: (id: string, data: Partial<PersonWithRelations>) => Promise<{ success: boolean; error?: string }>\n}) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [formData, setFormData] = useState<PersonFormData | null>(null)\n  const [companies, setCompanies] = useState<Company[]>([])\n\n  useEffect(() => {\n    async function fetchCompanies() {\n      const { data, error } = await getCompanies()\n      if (error) {\n        toast.error(\"Could not fetch companies.\")\n        console.error(error)\n      } else if (data) {\n        setCompanies(data)\n      }\n    }\n    fetchCompanies()\n  }, [])\n\n  // Extract initial values from the contact data\n  const initialEmails = data.emails?.map(e => e.email) || []\n  const initialPhones = data.phones?.map(p => p.phone) || []\n\n  const handleFormDataChange = useCallback((formData: PersonFormData) => {\n    setFormData(formData)\n  }, [])\n\n  const handleSubmit = async () => {\n    if (!formData || !updateAction) return\n\n    setIsSubmitting(true)\n    try {\n      const contactData = transformFormDataToContact(formData)\n      const result = await updateAction(data.id, contactData)\n      \n      if (result.success) {\n        router.refresh()\n        onSuccess?.()\n      } else {\n        console.error(\"Failed to update contact:\", result.error)\n        toast.error(\"Failed to update contact\", { description: result.error })\n      }\n    } catch (error) {\n      console.error(\"Error updating contact:\", error)\n      toast.error(\"An unexpected error occurred while updating the contact.\")\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        <PersonForm\n          initialFirstName={data.first_name || \"\"}\n          initialLastName={data.last_name || \"\"}\n          initialEmails={initialEmails}\n          initialPhones={initialPhones}\n          initialCity={data.city || \"\"}\n          initialState={data.state || \"\"}\n          initialCompany={data.company?.name || \"\"}\n          initialDescription={data.description || \"\"}\n          initialLinkedin={data.linkedin || \"\"}\n          initialJobTitle={data.job_title || \"\"}\n          onChange={handleFormDataChange}\n          availableCompanies={companies}\n        />\n      </div>\n      \n      <div className=\"flex justify-between gap-2 p-4 border-t bg-background\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={onCancel}\n          className=\"w-1/2\"\n        >\n          <X className=\"size-4 shrink-0\" /> Cancel\n        </Button>\n        <Button\n          onClick={handleSubmit}\n          disabled={isSubmitting || !formData}\n          className=\"w-1/2\"\n        >\n          <Save className=\"size-4 shrink-0\" />\n          {isSubmitting ? \"Saving...\" : \"Save Changes\"}\n        </Button>\n      </div>\n    </div>\n  )\n}\n\n// multi Edit Form Wrapper\nexport function ContactMultiEditForm({\n  selectedCount,\n  onSuccess,\n  onCancel,\n  updateActionMulti\n}: {\n  selectedCount: number\n  onSuccess?: () => void\n  onCancel?: () => void\n  updateActionMulti?: (ids: string[], data: Partial<PersonWithRelations>) => Promise<{ success: boolean; error?: string; updatedCount?: number }>\n}) {\n  const router = useRouter()\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [formData, setFormData] = useState<PersonFormData | null>(null)\n  const [companies, setCompanies] = useState<Company[]>([])\n\n  useEffect(() => {\n    async function fetchCompanies() {\n      const { data, error } = await getCompanies()\n      if (error) {\n        toast.error(\"Could not fetch companies.\")\n        console.error(error)\n      } else if (data) {\n        setCompanies(data)\n      }\n    }\n    fetchCompanies()\n  }, [])\n\n  const handleFormDataChange = useCallback((data: PersonFormData) => {\n    setFormData(data)\n  }, [])\n\n  const handleSubmit = async () => {\n    if (!formData || !updateActionMulti) return\n\n    setIsSubmitting(true)\n    try {\n      const contactData = transformFormDataToContact(formData)\n      \n      // Filter out undefined values for multi edit - only update fields that were actually modified\n      const filteredData = Object.fromEntries(\n        Object.entries(contactData).filter(([, value]) => {\n          if (value === undefined || value === null) return false\n          if (typeof value === 'string' && value.trim() === '') return false\n          if (Array.isArray(value) && value.length === 0) return false\n          return true\n        })\n      )\n      \n      // The updateActionMulti function will be called with the selected contact IDs\n      // by the DataTableRowEditMulti component\n      const result = await updateActionMulti([], filteredData)\n      \n      if (result.success) {\n        router.refresh()\n        onSuccess?.()\n        toast.success(\"Contacts updated successfully\", {\n          description: `${result.updatedCount || selectedCount} contact${(result.updatedCount || selectedCount) > 1 ? 's' : ''} updated.`\n        })\n      } else {\n        console.error(\"Failed to update contacts:\", result.error)\n        toast.error(\"Failed to update contacts\", { description: result.error })\n      }\n    } catch (error) {\n      console.error(\"Error updating contacts:\", error)\n      toast.error(\"An unexpected error occurred while updating the contacts.\")\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      <div className=\"flex-1 overflow-y-auto p-4\">\n\n        <PersonForm\n          onChange={handleFormDataChange}\n          availableCompanies={companies}\n          // Start with empty values for multi edit\n          initialFirstName=\"\"\n          initialLastName=\"\"\n          initialEmails={[]}\n          initialPhones={[]}\n          initialCity=\"\"\n          initialState=\"\"\n          initialCompany=\"\"\n          initialDescription=\"\"\n          initialLinkedin=\"\"\n          initialJobTitle=\"\"\n        />\n      </div>\n      \n      <div className=\"flex justify-between gap-2 p-4 border-t bg-background\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={onCancel}\n          className=\"w-1/2\"\n        >\n          <X className=\"size-4 shrink-0\" /> Cancel\n        </Button>\n        <Button\n          onClick={handleSubmit}\n          disabled={isSubmitting || !formData}\n          className=\"w-1/2\"\n        >\n          <Save className=\"size-4 shrink-0\" />\n          {isSubmitting ? \"Updating...\" : `Update ${selectedCount} Contact${selectedCount > 1 ? 's' : ''}`}\n        </Button>\n      </div>\n    </div>\n  )\n}",
      "type": "registry:component",
      "target": "app/person/_components/person-form-wrapper.tsx"
    },
    {
      "path": "registry/data-table/app/person/_lib/actions.ts",
      "content": "\"use server\"\n\nimport { createClient } from \"@/lib/supabase/server\"\nimport { revalidatePath } from \"next/cache\"\nimport { Person } from \"./validations\"\nimport { getCompanies as dbGetCompanies } from \"./queries\"\nimport type { SupabaseClient } from '@supabase/supabase-js'\n\ninterface PersonWithExtras extends Omit<Person, \"id\" | \"created_at\" | \"updated_at\"> {\n  _emails?: string[]\n  _phones?: string[]\n  company_name?: string\n}\n\nasync function findOrCreateCompany(supabase: SupabaseClient, companyName: string | undefined): Promise<string | null> {\n    if (!companyName) return null\n\n    // Check if company exists\n    const { data: existingCompany, error: findError } = await supabase\n        .schema(\"registry\")\n        .from(\"companies\")\n        .select(\"id\")\n        .eq(\"name\", companyName)\n        .single()\n\n    if (findError && findError.code !== 'PGRST116') { // PGRST116: no rows found\n        console.error(\"Error finding company:\", findError)\n        throw new Error(findError.message)\n    }\n\n    if (existingCompany) {\n        return existingCompany.id\n    }\n\n    // Create company if it doesn't exist\n    const { data: newCompany, error: createError } = await supabase\n        .schema(\"registry\")\n        .from(\"companies\")\n        .insert({ name: companyName })\n        .select(\"id\")\n        .single()\n\n    if (createError) {\n        console.error(\"Error creating company:\", createError)\n        throw new Error(createError.message)\n    }\n\n    return newCompany.id\n}\n\nexport async function createPerson(data: Record<string, unknown>) {\n  const supabase = await createClient()\n  \n  try {\n    // Extract emails, phones and company from the data\n    const { _emails, _phones, company_name, ...contactData } = data as PersonWithExtras\n    \n    if (company_name) {\n      const companyId = await findOrCreateCompany(supabase, company_name)\n      contactData.company_id = companyId\n    }\n\n    // Start a transaction by creating the contact first\n    const { data: newContact, error: contactError } = await supabase\n      .schema(\"registry\")\n      .from(\"contacts\")\n      .insert([contactData])\n      .select()\n      .single()\n    \n    if (contactError) {\n      console.error(\"Error creating contact:\", contactError)\n      return { success: false, error: contactError.message }\n    }\n    \n    // Create emails if provided\n    if (_emails && _emails.length > 0) {\n      const emailsToInsert = _emails.map((email, index) => ({\n        contact_id: newContact.id,\n        email: email,\n        display_order: index\n      }))\n      \n      const { error: emailError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_emails\")\n        .insert(emailsToInsert)\n      \n      if (emailError) {\n        console.error(\"Error creating emails:\", emailError)\n        // Optionally rollback by deleting the contact\n        await supabase.schema(\"registry\").from(\"contacts\").delete().eq(\"id\", newContact.id)\n        return { success: false, error: emailError.message }\n      }\n    }\n    \n    // Create phones if provided\n    if (_phones && _phones.length > 0) {\n      const phonesToInsert = _phones.map((phone, index) => ({\n        contact_id: newContact.id,\n        phone: phone,\n        display_order: index\n      }))\n      \n      const { error: phoneError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_phones\")\n        .insert(phonesToInsert)\n      \n      if (phoneError) {\n        console.error(\"Error creating phones:\", phoneError)\n        // Optionally rollback\n        await supabase.schema(\"registry\").from(\"contacts\").delete().eq(\"id\", newContact.id)\n        return { success: false, error: phoneError.message }\n      }\n    }\n    \n    revalidatePath(\"/contacts\")\n    return { success: true, data: newContact }\n  } catch (error) {\n    console.error(\"Unexpected error creating contact:\", error)\n    return { success: false, error: \"An unexpected error occurred\" }\n  }\n}\n\nexport async function updatePerson(id: string, data: Record<string, unknown>) {\n  const supabase = await createClient()\n  \n  try {\n    // Extract emails and phones from the data\n    const { _emails, _phones, company_name, ...contactData } = data as PersonWithExtras\n    \n    if (company_name !== undefined) {\n      const companyId = await findOrCreateCompany(supabase, company_name)\n      contactData.company_id = companyId\n    }\n    \n    // Update the contact\n    const { data: updatedContact, error: contactError } = await supabase\n      .schema(\"registry\")\n      .from(\"contacts\")\n      .update(contactData)\n      .eq(\"id\", id)\n      .select()\n      .single()\n    \n    if (contactError) {\n      console.error(\"Error updating contact:\", contactError)\n      return { success: false, error: contactError.message }\n    }\n    \n    // Update emails if provided\n    if (_emails !== undefined) {\n      // Delete existing emails\n      const { error: deleteEmailError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_emails\")\n        .delete()\n        .eq(\"contact_id\", id)\n      \n      if (deleteEmailError) {\n        console.error(\"Error deleting existing emails:\", deleteEmailError)\n        return { success: false, error: deleteEmailError.message }\n      }\n      \n      // Insert new emails\n      if (_emails.length > 0) {\n        const emailsToInsert = _emails.map((email, index) => ({\n          contact_id: id,\n          email: email,\n          display_order: index\n        }))\n        \n        const { error: emailError } = await supabase\n          .schema(\"registry\")\n          .from(\"contact_emails\")\n          .insert(emailsToInsert)\n        \n        if (emailError) {\n          console.error(\"Error creating emails:\", emailError)\n          return { success: false, error: emailError.message }\n        }\n      }\n    }\n    \n    // Update phones if provided\n    if (_phones !== undefined) {\n      // Delete existing phones\n      const { error: deletePhoneError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_phones\")\n        .delete()\n        .eq(\"contact_id\", id)\n      \n      if (deletePhoneError) {\n        console.error(\"Error deleting existing phones:\", deletePhoneError)\n        return { success: false, error: deletePhoneError.message }\n      }\n      \n      // Insert new phones\n      if (_phones.length > 0) {\n        const phonesToInsert = _phones.map((phone, index) => ({\n          contact_id: id,\n          phone: phone,\n          display_order: index\n        }))\n        \n        const { error: phoneError } = await supabase\n          .schema(\"registry\")\n          .from(\"contact_phones\")\n          .insert(phonesToInsert)\n        \n        if (phoneError) {\n          console.error(\"Error creating phones:\", phoneError)\n          return { success: false, error: phoneError.message }\n        }\n      }\n    }\n    \n    revalidatePath(\"/contacts\")\n    return { success: true, data: updatedContact }\n  } catch (error) {\n    console.error(\"Unexpected error updating contact:\", error)\n    return { success: false, error: \"An unexpected error occurred\" }\n  }\n}\n\nexport async function getCompanies() {\n  return await dbGetCompanies()\n}\n\nexport async function multiUpdatePersons(personIds: string[], data: Record<string, unknown>) {\n  const supabase = await createClient()\n  \n  try {\n    // Extract emails, phones and company from the data\n    const { _emails, _phones, company_name, ...contactData } = data as PersonWithExtras\n    \n    // Only process fields that are actually provided (not undefined)\n    const fieldsToUpdate = Object.fromEntries(\n      Object.entries(contactData).filter(([, value]) => value !== undefined)\n    )\n    \n    if (company_name !== undefined) {\n      const companyId = await findOrCreateCompany(supabase, company_name)\n      fieldsToUpdate.company_id = companyId\n    }\n    \n    // Update all contacts with the provided data\n    if (Object.keys(fieldsToUpdate).length > 0) {\n      const { error: contactError } = await supabase\n        .schema(\"registry\")\n        .from(\"contacts\")\n        .update(fieldsToUpdate)\n        .in(\"id\", personIds)\n      \n      if (contactError) {\n        console.error(\"Error multi updating contacts:\", contactError)\n        return { success: false, error: contactError.message }\n      }\n    }\n    \n    // Handle multi email updates if provided\n    if (_emails !== undefined) {\n      // Delete existing emails for all contacts\n      const { error: deleteEmailError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_emails\")\n        .delete()\n        .in(\"contact_id\", personIds)\n      \n      if (deleteEmailError) {\n        console.error(\"Error deleting existing emails:\", deleteEmailError)\n        return { success: false, error: deleteEmailError.message }\n      }\n      \n      // Insert new emails for all contacts\n      if (_emails.length > 0) {\n        const emailsToInsert = personIds.flatMap(contactId =>\n          _emails.map((email, index) => ({\n            contact_id: contactId,\n            email: email,\n            display_order: index\n          }))\n        )\n        \n        const { error: emailError } = await supabase\n          .schema(\"registry\")\n          .from(\"contact_emails\")\n          .insert(emailsToInsert)\n        \n        if (emailError) {\n          console.error(\"Error creating emails:\", emailError)\n          return { success: false, error: emailError.message }\n        }\n      }\n    }\n    \n    // Handle multi phone updates if provided\n    if (_phones !== undefined) {\n      // Delete existing phones for all contacts\n      const { error: deletePhoneError } = await supabase\n        .schema(\"registry\")\n        .from(\"contact_phones\")\n        .delete()\n        .in(\"contact_id\", personIds)\n      \n      if (deletePhoneError) {\n        console.error(\"Error deleting existing phones:\", deletePhoneError)\n        return { success: false, error: deletePhoneError.message }\n      }\n      \n      // Insert new phones for all contacts\n      if (_phones.length > 0) {\n        const phonesToInsert = personIds.flatMap(contactId =>\n          _phones.map((phone, index) => ({\n            contact_id: contactId,\n            phone: phone,\n            display_order: index\n          }))\n        )\n        \n        const { error: phoneError } = await supabase\n          .schema(\"registry\")\n          .from(\"contact_phones\")\n          .insert(phonesToInsert)\n        \n        if (phoneError) {\n          console.error(\"Error creating phones:\", phoneError)\n          return { success: false, error: phoneError.message }\n        }\n      }\n    }\n    \n    revalidatePath(\"/contacts\")\n    return { success: true, updatedCount: personIds.length }\n  } catch (error) {\n    console.error(\"Unexpected error multi updating contacts:\", error)\n    return { success: false, error: \"An unexpected error occurred\" }\n  }\n}\n\nexport async function deletePersons(personIds: string[]) {\n  const supabase = await createClient()\n  \n  try {\n    // Delete related emails first (due to foreign key constraints)\n    const { error: emailError } = await supabase\n      .schema(\"registry\")\n      .from(\"contact_emails\")\n      .delete()\n      .in(\"contact_id\", personIds)\n    \n    if (emailError) {\n      console.error(\"Error deleting emails:\", emailError)\n      return { success: false, error: emailError.message }\n    }\n    \n    // Delete related phones\n    const { error: phoneError } = await supabase\n      .schema(\"registry\")\n      .from(\"contact_phones\")\n      .delete()\n      .in(\"contact_id\", personIds)\n    \n    if (phoneError) {\n      console.error(\"Error deleting phones:\", phoneError)\n      return { success: false, error: phoneError.message }\n    }\n    \n    // Now delete the contacts\n    const { error } = await supabase\n      .schema(\"registry\")\n      .from(\"contacts\")\n      .delete()\n      .in(\"id\", personIds)\n    \n    if (error) {\n      console.error(\"Error deleting contacts:\", error)\n      return { success: false, error: error.message }\n    }\n    \n    revalidatePath(\"/contacts\")\n      return { success: true, deletedCount: personIds.length }\n  } catch (error) {\n    console.error(\"Unexpected error deleting contacts:\", error)\n    return { success: false, error: \"An unexpected error occurred\" }\n  }\n}",
      "type": "registry:lib",
      "target": "app/person/_lib/actions.ts"
    },
    {
      "path": "registry/data-table/app/person/_lib/queries.ts",
      "content": "import { createClient } from \"@/lib/supabase/server\"\nimport { parseSearchParams, SearchParams } from \"@/lib/data-table\"\nimport { PersonWithRelations, Company } from \"./validations\"\nimport { PostgrestError } from \"@supabase/supabase-js\"\n\nexport async function getCompanies(): Promise<{\n  data: Company[],\n  error: PostgrestError | null\n}> {\n  const supabase = await createClient()\n  const { data, error } = await supabase\n    .schema(\"registry\")\n    .from(\"companies\")\n    .select(\"*\")\n    .order(\"name\", { ascending: true })\n  \n  return { data: data ?? [], error }\n}\n\nexport async function getPersons(searchParams: SearchParams): Promise<{\n  data: PersonWithRelations[],\n  count: number,\n  error: PostgrestError | null\n}> {\n  const supabase = await createClient()\n  const {\n    pagination,\n    sorting,\n    columnFilters\n  } = parseSearchParams(searchParams)\n\n  const { pageIndex, pageSize } = pagination ?? { pageIndex: 0, pageSize: 10 }\n  const sort = sorting ?? []\n  const filters = columnFilters ?? []\n\n  let query = supabase\n    .schema(\"registry\")\n    .from(\"contacts\")\n    .select(`\n      *,\n      company:companies(*),\n      emails:contact_emails(*),\n      phones:contact_phones(*)\n    `, { count: \"exact\" })\n\n  // Sorting\n  if (sort.length > 0) {\n    sort.forEach(s => {\n      // Handle computed columns and related data sorting\n      switch (s.id) {\n        case \"display_name\":\n          query = query.order(\"first_name\", { ascending: !s.desc })\n          break\n        case \"company_name\":\n          // Note: Sorting by related table requires a different approach\n          // For now, we'll sort by company_id and handle display sorting client-side\n          query = query.order(\"company_id\", { ascending: !s.desc })\n          break\n        case \"primary_email\":\n        case \"primary_phone\":\n          // These are computed from related tables, sort by contact name instead\n          query = query.order(\"first_name\", { ascending: !s.desc })\n          break\n        case \"location\":\n          query = query.order(\"city\", { ascending: !s.desc })\n          break\n        default:\n          query = query.order(s.id, { ascending: !s.desc })\n      }\n    })\n  } else {\n    query = query.order(\"first_name\", { ascending: true })\n  }\n\n  // Filtering\n  filters.forEach(filter => {\n    const { id: columnId, value: filterValue } = filter\n    if (typeof filterValue === 'object' && filterValue !== null && 'operator' in filterValue) {\n      const { operator, value } = filterValue as { operator: string, value: unknown }\n\n      if (!operator || value === null || value === undefined || (typeof value === 'string' && value === '')) return\n\n      // Handle computed/virtual columns\n      switch (columnId) {\n        case \"display_name\":\n          // Search in both first_name and last_name\n          if (operator === \"iLike\") {\n            query = query.or(`first_name.ilike.%${value}%,last_name.ilike.%${value}%`)\n          }\n          break\n        case \"company_name\":\n          // Filter by company name through the relationship\n          // Note: This requires a more complex query structure\n          if (operator === \"iLike\") {\n            // We'll need to handle this client-side or use a different approach\n            // For now, skip company name filtering in the query\n            console.warn(\"Company name filtering not implemented at query level\")\n          }\n          break\n        case \"primary_email\":\n          // Filter contacts that have emails matching the criteria\n          // This requires a subquery approach\n          if (operator === \"iLike\") {\n            // We'll handle this client-side for now\n            console.warn(\"Email filtering not implemented at query level\")\n          }\n          break\n        case \"primary_phone\":\n          // Similar to email filtering\n          if (operator === \"iLike\") {\n            console.warn(\"Phone filtering not implemented at query level\")\n          }\n          break\n        case \"location\":\n          // Search in both city and state\n          if (operator === \"iLike\") {\n            query = query.or(`city.ilike.%${value}%,state.ilike.%${value}%`)\n          }\n          break\n        default:\n          // Handle regular columns\n          switch (operator) {\n            case \"iLike\":\n              query = query.ilike(columnId, `%${value}%`)\n              break\n            case \"notILike\":\n              query = query.not(columnId, 'ilike', `%${value}%`)\n              break\n            case \"eq\":\n              query = query.eq(columnId, value)\n              break\n            case \"ne\":\n              query = query.neq(columnId, value)\n              break\n            case \"lt\":\n              query = query.lt(columnId, value)\n              break\n            case \"gt\":\n              query = query.gt(columnId, value)\n              break\n            case \"inArray\":\n              query = query.in(columnId, value as (string | number)[])\n              break\n            case \"notInArray\":\n              query = query.not(columnId, 'in', `(${(value as (string | number)[]).join(',')})`)\n              break\n            case \"isEmpty\":\n              query = query.or(`${columnId}.is.null,${columnId}.eq.\"\"`)\n              break\n            case \"isNotEmpty\":\n              query = query.not(columnId, 'is', null).not(columnId, 'eq', '\"\"')\n              break\n            case \"isBetween\":\n              if (Array.isArray(value) && value.length === 2) {\n                query = query.gte(columnId, value[0]).lte(columnId, value[1])\n              }\n              break\n            default:\n              break\n          }\n      }\n    }\n  })\n\n  // Pagination\n  const from = pageIndex * pageSize\n  const to = from + pageSize - 1\n  query = query.range(from, to)\n\n  const { data, count, error } = await query\n\n  // Sort emails and phones by display_order for consistent primary selection\n  const processedData = (data as unknown as PersonWithRelations[])?.map(person => ({\n    ...person,\n    emails: person.emails?.sort((a, b) => a.display_order - b.display_order) || [],\n    phones: person.phones?.sort((a, b) => a.display_order - b.display_order) || []\n  })) || []\n\n  return {\n    data: processedData,\n    count: count ?? 0,\n    error\n  }\n}\n\n",
      "type": "registry:lib",
      "target": "app/person/_lib/queries.ts"
    },
    {
      "path": "registry/data-table/app/person/_lib/validations.ts",
      "content": "// Base table types (matching your database schema)\nexport type Person = {\n  id: string;\n  created_at?: string;\n  updated_at?: string;\n  first_name?: string;\n  last_name?: string;\n  city?: string;\n  state?: string;\n  company_id?: string | null;\n  job_title?: string;\n  description?: string;\n  linkedin?: string;\n}\n\nexport type Company = {\n  id: string;\n  created_at?: string;\n  name: string;\n  description?: string;\n}\n\nexport type PersonEmail = {\n  id: string;\n  contact_id: string;\n  email: string;\n  display_order: number;\n  created_at?: string;\n}\n\nexport type PersonPhone = {\n  id: string;\n  contact_id: string;\n  phone: string;\n  display_order: number;\n  created_at?: string;\n}\n\n// Enhanced types with relationships\nexport type PersonWithCompany = Person & {\n  company?: Company;\n}\n\nexport type PersonWithRelations = Person & {\n  company?: Company;\n  emails: PersonEmail[];\n  phones: PersonPhone[];\n}\n\n// Form-specific types (for your React component)\nexport type PersonFormData = {\n  firstName: string;\n  lastName: string;\n  emails: string[];\n  phones: string[];\n  city: string;\n  state: string;\n  company: string;\n  description: string;\n  linkedin: string;\n  jobTitle: string;\n}\n\n// API response types\nexport type ContactListResponse = {\n  contacts: PersonWithCompany[];\n  total: number;\n}\n\nexport type ContactDetailResponse = PersonWithRelations;\n\n// Insert/Update types (without generated fields)\nexport type PersonInsert = Omit<Person, 'id' | 'created_at' | 'updated_at'>;\nexport type PersonUpdate = Partial<PersonInsert>;\n\nexport type PersonEmailInsert = Omit<PersonEmail, 'id' | 'created_at'>;\nexport type PersonPhoneInsert = Omit<PersonPhone, 'id' | 'created_at'>;\n\nexport type CompanyInsert = Omit<Company, 'id' | 'created_at'>;\n\n// Utility types for the component\nexport type PersonData = {\n  firstName: string;\n  lastName: string;\n  emails: string[];\n  phones: string[];\n  city: string;\n  state: string;\n  company: string;\n  description: string;\n  linkedin: string;\n  jobTitle: string;\n}",
      "type": "registry:lib",
      "target": "app/person/_lib/validations.ts"
    }
  ]
}